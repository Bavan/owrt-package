From 125d099662305a43c9a6d55d0255aaad9383e923 Mon Sep 17 00:00:00 2001
From: Simon Horman <horms@verge.net.au>
Date: Sun, 24 Feb 2013 17:23:38 +0900
Subject: [PATCH 118/126] MEDIUM: Move health element to struct check

This is in preparation for associating a agent check
with a server which runs as well as the server's existing check.

Signed-off-by: Simon Horman <horms@verge.net.au>
---
 include/types/server.h |  3 ++-
 src/cfgparse.c         | 11 +++++------
 src/checks.c           | 50 +++++++++++++++++++++++++-------------------------
 src/dumpstats.c        | 12 ++++++------
 src/proto_http.c       |  2 +-
 src/server.c           |  4 ++--
 6 files changed, 41 insertions(+), 41 deletions(-)

diff --git a/include/types/server.h b/include/types/server.h
index bcde01b..1df56e9 100644
--- a/include/types/server.h
+++ b/include/types/server.h
@@ -120,6 +120,8 @@ struct check {
 	int inter, fastinter, downinter;        /* checks: time in milliseconds */
 	int result;				/* health-check result : SRV_CHK_* */
 	int state;				/* health-check result : CHK_* */
+	int health;				/* 0 to server->rise-1 = bad;
+						 * rise to server->rise+server->fall-1 = good */
 	int type;				/* Check type, one of PR_O2_*_CHK */
 	struct server *server;			/* back-pointer to server */
 };
@@ -151,7 +153,6 @@ struct server {
 
 	struct server *tracknext, *track;	/* next server in a tracking list, tracked server */
 	char *trackit;				/* temporary variable to make assignment deferrable */
-	int health;				/* 0->rise-1 = bad; rise->rise+fall-1 = good */
 	int consecutive_errors;			/* current number of consecutive errors */
 	int rise, fall;				/* time in iterations */
 	int consecutive_errors_limit;		/* number of consecutive errors that triggers an event */
diff --git a/src/cfgparse.c b/src/cfgparse.c
index b16c310..0303db8 100644
--- a/src/cfgparse.c
+++ b/src/cfgparse.c
@@ -4299,9 +4299,8 @@ stats_error_parsing:
 			newsrv->uweight = newsrv->iweight
 						= curproxy->defsrv.iweight;
 
-			newsrv->health = newsrv->rise;	/* up, but will fall down at first failure */
-
 			newsrv->check.status	= HCHK_STATUS_INI;
+			newsrv->check.health	= newsrv->rise;	/* up, but will fall down at first failure */
 			newsrv->check.server	= newsrv;
 
 			cur_arg = 3;
@@ -4337,8 +4336,8 @@ stats_error_parsing:
 					goto out;
 				}
 
-				if (newsrv->health)
-					newsrv->health = newsrv->rise;
+				if (newsrv->check.health)
+					newsrv->check.health = newsrv->rise;
 				cur_arg += 2;
 			}
 			else if (!strcmp(args[cur_arg], "fall")) {
@@ -4519,7 +4518,7 @@ stats_error_parsing:
 			else if (!defsrv && !strcmp(args[cur_arg], "disabled")) {
 				newsrv->state |= SRV_MAINTAIN;
 				newsrv->state &= ~SRV_RUNNING;
-				newsrv->health = 0;
+				newsrv->check.health = 0;
 				cur_arg += 1;
 			}
 			else if (!defsrv && !strcmp(args[cur_arg], "observe")) {
@@ -6809,7 +6808,7 @@ out_uri_auth_compat:
 				if (srv->state & SRV_MAINTAIN) {
 					newsrv->state |= SRV_MAINTAIN;
 					newsrv->state &= ~SRV_RUNNING;
-					newsrv->health = 0;
+					newsrv->check.health = 0;
 				}
 
 				newsrv->track = srv;
diff --git a/src/checks.c b/src/checks.c
index c37afbd..44ad4b7 100644
--- a/src/checks.c
+++ b/src/checks.c
@@ -229,8 +229,8 @@ static void set_server_check_status(struct check *check, short status, const cha
 	}
 
 	if (s->proxy->options2 & PR_O2_LOGHCHKS &&
-	(((s->health != 0) && (check->result & SRV_CHK_FAILED)) ||
-	    ((s->health != s->rise + s->fall - 1) && (check->result & SRV_CHK_PASSED)) ||
+	(((check->health != 0) && (check->result & SRV_CHK_FAILED)) ||
+	    ((check->health != s->rise + s->fall - 1) && (check->result & SRV_CHK_PASSED)) ||
 	    ((s->state & SRV_GOINGDOWN) && !(check->result & SRV_CHK_DISABLE)) ||
 	    (!(s->state & SRV_GOINGDOWN) && (check->result & SRV_CHK_DISABLE)))) {
 
@@ -239,7 +239,7 @@ static void set_server_check_status(struct check *check, short status, const cha
 		chunk_reset(&trash);
 
 		/* FIXME begin: calculate local version of the health/rise/fall/state */
-		health = s->health;
+		health = check->health;
 		rise   = s->rise;
 		fall   = s->fall;
 		state  = s->state;
@@ -395,10 +395,10 @@ void set_server_down(struct check *check)
 	int xferred;
 
 	if (s->state & SRV_MAINTAIN) {
-		s->health = s->rise;
+		check->health = s->rise;
 	}
 
-	if (s->health == s->rise || s->track) {
+	if (check->health == s->rise || s->track) {
 		int srv_was_paused = s->state & SRV_GOINGDOWN;
 		int prev_srv_count = s->proxy->srv_bck + s->proxy->srv_act;
 
@@ -451,7 +451,7 @@ void set_server_down(struct check *check)
 					set_server_down(check);
 	}
 
-	s->health = 0; /* failure */
+	check->health = 0; /* failure */
 }
 
 void set_server_up(struct check *check) {
@@ -462,10 +462,10 @@ void set_server_up(struct check *check) {
 	unsigned int old_state = s->state;
 
 	if (s->state & SRV_MAINTAIN) {
-		s->health = s->rise;
+		check->health = s->rise;
 	}
 
-	if (s->health == s->rise || s->track) {
+	if (check->health == s->rise || s->track) {
 		if (s->proxy->srv_bck == 0 && s->proxy->srv_act == 0) {
 			if (s->proxy->last_change < now.tv_sec)		// ignore negative times
 				s->proxy->down_time += now.tv_sec - s->proxy->last_change;
@@ -534,8 +534,8 @@ void set_server_up(struct check *check) {
 					set_server_up(check);
 	}
 
-	if (s->health >= s->rise)
-		s->health = s->rise + s->fall - 1; /* OK now */
+	if (check->health >= s->rise)
+		check->health = s->rise + s->fall - 1; /* OK now */
 
 }
 
@@ -660,8 +660,8 @@ void health_adjust(struct server *s, short status)
 
 		case HANA_ONERR_SUDDTH:
 		/* simulate a pre-fatal failed health check */
-			if (s->health > s->rise)
-				s->health = s->rise + 1;
+			if (s->check.health > s->rise)
+				s->check.health = s->rise + 1;
 
 			/* no break - fall through */
 
@@ -669,8 +669,8 @@ void health_adjust(struct server *s, short status)
 		/* simulate a failed health check */
 			set_server_check_status(&s->check, HCHK_STATUS_HANA, trash.str);
 
-			if (s->health > s->rise) {
-				s->health--; /* still good */
+			if (s->check.health > s->rise) {
+				s->check.health--; /* still good */
 				s->counters.failed_checks++;
 			}
 			else
@@ -680,7 +680,7 @@ void health_adjust(struct server *s, short status)
 
 		case HANA_ONERR_MARKDWN:
 		/* mark server down */
-			s->health = s->rise;
+			s->check.health = s->rise;
 			set_server_check_status(&s->check, HCHK_STATUS_HANA, trash.str);
 			set_server_down(&s->check);
 
@@ -720,7 +720,7 @@ static int httpchk_build_status_header(struct server *s, char *buffer)
 	if (!(s->state & SRV_CHECKED))
 		sv_state = 6; /* should obviously never happen */
 	else if (s->state & SRV_RUNNING) {
-		if (s->health == s->rise + s->fall - 1)
+		if (s->check.health == s->rise + s->fall - 1)
 			sv_state = 3; /* UP */
 		else
 			sv_state = 2; /* going down */
@@ -728,7 +728,7 @@ static int httpchk_build_status_header(struct server *s, char *buffer)
 		if (s->state & SRV_GOINGDOWN)
 			sv_state += 2;
 	} else {
-		if (s->health)
+		if (s->check.health)
 			sv_state = 1; /* going up */
 		else
 			sv_state = 0; /* DOWN */
@@ -736,7 +736,7 @@ static int httpchk_build_status_header(struct server *s, char *buffer)
 
 	hlen += sprintf(buffer + hlen,
 			     srv_hlt_st[sv_state],
-			     (s->state & SRV_RUNNING) ? (s->health - s->rise + 1) : (s->health),
+			     (s->state & SRV_RUNNING) ? (s->check.health - s->rise + 1) : (s->check.health),
 			     (s->state & SRV_RUNNING) ? (s->fall) : (s->rise));
 
 	hlen += sprintf(buffer + hlen, "; name=%s/%s; node=%s; weight=%d/%d; scur=%d/%d; qcur=%d",
@@ -1421,8 +1421,8 @@ static struct task *process_chk(struct task *t)
 		/* here, we have seen a synchronous error, no fd was allocated */
 
 		check->state &= ~CHK_STATE_RUNNING;
-		if (s->health > s->rise) {
-			s->health--; /* still good */
+		if (check->health > s->rise) {
+			check->health--; /* still good */
 			s->counters.failed_checks++;
 		}
 		else
@@ -1494,9 +1494,9 @@ static struct task *process_chk(struct task *t)
 			conn_full_close(conn);
 		}
 
-		if (s->check.result & SRV_CHK_FAILED) {    /* a failure or timeout detected */
-			if (s->health > s->rise) {
-				s->health--; /* still good */
+		if (check->result & SRV_CHK_FAILED) {    /* a failure or timeout detected */
+			if (check->health > s->rise) {
+				check->health--; /* still good */
 				s->counters.failed_checks++;
 			}
 			else
@@ -1511,8 +1511,8 @@ static struct task *process_chk(struct task *t)
 					set_server_disabled(check);
 			}
 
-			if (s->health < s->rise + s->fall - 1) {
-				s->health++; /* was bad, stays for a while */
+			if (check->health < s->rise + s->fall - 1) {
+				check->health++; /* was bad, stays for a while */
 				set_server_up(check);
 			}
 		}
diff --git a/src/dumpstats.c b/src/dumpstats.c
index be0aac6..e23a766 100644
--- a/src/dumpstats.c
+++ b/src/dumpstats.c
@@ -1309,14 +1309,14 @@ static int stats_sock_parse_request(struct stream_interface *si, char *line)
 					*/
 					if (sv->track->state & SRV_RUNNING) {
 						set_server_up(&sv->check);
-						sv->health = sv->rise;	/* up, but will fall down at first failure */
+						sv->check.health = sv->rise;	/* up, but will fall down at first failure */
 					} else {
 						sv->state &= ~SRV_MAINTAIN;
 						set_server_down(&sv->check);
 					}
 				} else {
 					set_server_up(&sv->check);
-					sv->health = sv->rise;	/* up, but will fall down at first failure */
+					sv->check.health = sv->rise;	/* up, but will fall down at first failure */
 				}
 			}
 
@@ -2266,7 +2266,7 @@ static int stats_dump_sv_stats(struct stream_interface *si, struct proxy *px, in
 			chunk_appendf(&trash, "%s ", human_time(now.tv_sec - ref->last_change, 1));
 			chunk_appendf(&trash,
 			              srv_hlt_st[state],
-			              (ref->state & SRV_RUNNING) ? (ref->health - ref->rise + 1) : (ref->health),
+			              (ref->state & SRV_RUNNING) ? (ref->check.health - ref->rise + 1) : (ref->check.health),
 			              (ref->state & SRV_RUNNING) ? (ref->fall) : (ref->rise));
 		}
 
@@ -2378,7 +2378,7 @@ static int stats_dump_sv_stats(struct stream_interface *si, struct proxy *px, in
 		else
 			chunk_appendf(&trash,
 			              srv_hlt_st[state],
-			              (ref->state & SRV_RUNNING) ? (ref->health - ref->rise + 1) : (ref->health),
+			              (ref->state & SRV_RUNNING) ? (ref->check.health - ref->rise + 1) : (ref->check.health),
 			              (ref->state & SRV_RUNNING) ? (ref->fall) : (ref->rise));
 
 		chunk_appendf(&trash,
@@ -2950,7 +2950,7 @@ static int stats_dump_proxy_to_buffer(struct stream_interface *si, struct proxy
 			if (!(svs->state & SRV_CHECKED))
 				sv_state = 6;
 			else if (svs->state & SRV_RUNNING) {
-				if (svs->health == svs->rise + svs->fall - 1)
+				if (svs->check.health == svs->rise + svs->fall - 1)
 					sv_state = 3; /* UP */
 				else
 					sv_state = 2; /* going down */
@@ -2959,7 +2959,7 @@ static int stats_dump_proxy_to_buffer(struct stream_interface *si, struct proxy
 					sv_state += 2;
 			}
 			else
-				if (svs->health)
+				if (svs->check.health)
 					sv_state = 1; /* going up */
 				else
 					sv_state = 0; /* DOWN */
diff --git a/src/proto_http.c b/src/proto_http.c
index d9d989b..b5e912e 100644
--- a/src/proto_http.c
+++ b/src/proto_http.c
@@ -2920,7 +2920,7 @@ int http_process_req_stat_post(struct stream_interface *si, struct http_txn *txn
 						if ((px->state != PR_STSTOPPED) && (sv->state & SRV_MAINTAIN)) {
 							/* Already in maintenance, we can change the server state */
 							set_server_up(&sv->check);
-							sv->health = sv->rise;	/* up, but will fall down at first failure */
+							sv->check.health = sv->rise;	/* up, but will fall down at first failure */
 							altered_servers++;
 							total_servers++;
 						}
diff --git a/src/server.c b/src/server.c
index 87ce061..dd6e9e6 100644
--- a/src/server.c
+++ b/src/server.c
@@ -34,10 +34,10 @@ int srv_getinter(const struct check *check)
 {
 	const struct server *s = check->server;
 
-	if ((s->state & SRV_CHECKED) && (s->health == s->rise + s->fall - 1))
+	if ((s->state & SRV_CHECKED) && (check->health == s->rise + s->fall - 1))
 		return check->inter;
 
-	if (!(s->state & SRV_RUNNING) && s->health==0)
+	if (!(s->state & SRV_RUNNING) && check->health == 0)
 		return (check->downinter)?(check->downinter):(check->inter);
 
 	return (check->fastinter)?(check->fastinter):(check->inter);
-- 
1.8.1.5

