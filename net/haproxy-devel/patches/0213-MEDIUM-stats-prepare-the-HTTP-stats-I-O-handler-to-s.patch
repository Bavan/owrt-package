From 96d44918f73842caa48594b3bdfe2971687b7a40 Mon Sep 17 00:00:00 2001
From: Willy Tarreau <w@1wt.eu>
Date: Fri, 22 Nov 2013 12:25:24 +0100
Subject: [PATCH 213/277] MEDIUM: stats: prepare the HTTP stats I/O handler to
 support more states

In preparation for moving the POST processing to the applet, we first
add new states to the HTTP I/O handler. Till now st0 was only 0/1 for
start/end. We now replace it with an enum.
---
 include/proto/dumpstats.h |  6 ++++++
 src/dumpstats.c           | 18 +++++++++++-------
 src/proto_http.c          |  3 ++-
 3 files changed, 19 insertions(+), 8 deletions(-)

diff --git a/include/proto/dumpstats.h b/include/proto/dumpstats.h
index 9b41961..653067b 100644
--- a/include/proto/dumpstats.h
+++ b/include/proto/dumpstats.h
@@ -54,6 +54,12 @@
 #define STAT_CLI_O_SET  10  /* set entries in tables */
 #define STAT_CLI_O_STAT 11  /* dump stats */
 
+/* HTTP stats : applet.st0 */
+enum {
+	STAT_HTTP_DONE = 0,  /* finished */
+	STAT_HTTP_DUMP,      /* dumping stats */
+};
+
 /* HTML form to limit output scope */
 #define STAT_SCOPE_TXT_MAXLEN 20      /* max len for scope substring */
 #define STAT_SCOPE_INPUT_NAME "scope" /* pattern form scope name <input> in html form */
diff --git a/src/dumpstats.c b/src/dumpstats.c
index b78ce44..ffaebfd 100644
--- a/src/dumpstats.c
+++ b/src/dumpstats.c
@@ -3479,7 +3479,7 @@ static int stats_dump_stat_to_buffer(struct stream_interface *si, struct uri_aut
 
 /* This I/O handler runs as an applet embedded in a stream interface. It is
  * used to send HTTP stats over a TCP socket. The mechanism is very simple.
- * si->applet.st0 becomes non-zero once the transfer is finished. The handler
+ * si->applet.st0 contains the operation in progress (dump, done). The handler
  * automatically unregisters itself once transfer is complete.
  */
 static void http_stats_io_handler(struct stream_interface *si)
@@ -3493,21 +3493,25 @@ static void http_stats_io_handler(struct stream_interface *si)
 
 	/* check that the output is not closed */
 	if (res->flags & (CF_SHUTW|CF_SHUTW_NOW))
-		si->applet.st0 = 1;
+		si->applet.st0 = STAT_HTTP_DONE;
 
-	if (!si->applet.st0) {
+	switch (si->applet.st0) {
+	case STAT_HTTP_DUMP:
 		if (stats_dump_stat_to_buffer(si, s->be->uri_auth)) {
-			si->applet.st0 = 1;
+			si->applet.st0 = STAT_HTTP_DONE;
 			si_shutw(si);
 		}
+		break;
 	}
 
 	if ((res->flags & CF_SHUTR) && (si->state == SI_ST_EST))
 		si_shutw(si);
 
-	if ((req->flags & CF_SHUTW) && (si->state == SI_ST_EST) && si->applet.st0) {
-		si_shutr(si);
-		res->flags |= CF_READ_NULL;
+	if (si->applet.st0 == STAT_HTTP_DONE) {
+		if ((req->flags & CF_SHUTW) && (si->state == SI_ST_EST)) {
+			si_shutr(si);
+			res->flags |= CF_READ_NULL;
+		}
 	}
 
 	/* update all other flags and resync with the other side */
diff --git a/src/proto_http.c b/src/proto_http.c
index becb4ae..faa060d 100644
--- a/src/proto_http.c
+++ b/src/proto_http.c
@@ -3130,7 +3130,8 @@ int http_handle_stats(struct session *s, struct channel *req)
 	s->task->nice = -32; /* small boost for HTTP statistics */
 	stream_int_register_handler(s->rep->prod, &http_stats_applet);
 	s->target = s->rep->prod->conn->target; // for logging only
-	s->rep->prod->applet.st0 = s->rep->prod->applet.st1 = s->rep->prod->applet.st2 = 0;
+	s->rep->prod->applet.st0 = STAT_HTTP_DUMP;
+	s->rep->prod->applet.st1 = s->rep->prod->applet.st2 = 0;
 	req->analysers = 0;
 	return 1;
 }
-- 
1.8.1.5

