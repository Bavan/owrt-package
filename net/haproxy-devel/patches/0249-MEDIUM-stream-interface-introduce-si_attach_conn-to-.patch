From 2a6e8802c0d471e1886bcb7cb24f161140e70ef5 Mon Sep 17 00:00:00 2001
From: Willy Tarreau <w@1wt.eu>
Date: Thu, 24 Oct 2013 15:50:53 +0200
Subject: [PATCH 249/277] MEDIUM: stream-interface: introduce si_attach_conn to
 replace si_prepare_conn

si_prepare_conn() is not appropriate in our case as it both initializes and
attaches the connection to the stream interface. Due to the asymmetry between
accept() and connect(), it causes some fields such as the control and transport
layers to be reinitialized.

Now that we can separately initialize these fields using conn_prepare(), let's
break this function to only attach the connection to the stream interface.

Also, by analogy, si_prepare_none() was renamed si_detach(), and
si_prepare_applet() was renamed si_attach_applet().
---
 include/proto/stream_interface.h | 16 ++++++----------
 src/backend.c                    |  6 ++++--
 src/peers.c                      |  3 ++-
 src/session.c                    |  5 +++--
 src/stream_interface.c           |  2 +-
 5 files changed, 16 insertions(+), 16 deletions(-)

diff --git a/include/proto/stream_interface.h b/include/proto/stream_interface.h
index 6bedaff..511099c 100644
--- a/include/proto/stream_interface.h
+++ b/include/proto/stream_interface.h
@@ -70,29 +70,25 @@ static inline void si_set_state(struct stream_interface *si, int state)
 	si->state = si->prev_state = state;
 }
 
-static inline void si_prepare_none(struct stream_interface *si)
+static inline void si_detach(struct stream_interface *si)
 {
 	si->ops = &si_embedded_ops;
 	si->end = NULL;
 	si->appctx.applet = NULL;
 }
 
-/* Assign the stream interface's pre-allocated connection to the end point,
- * and leave the connection's context untouched. This is used for incoming
- * and outgoing connections. The caller is responsible for ensuring that
- * si->conn already points to the connection.
+/* Attach connection <conn> to the stream interface <si>. The stream interface
+ * is configured to work with a connection and the connection it configured
+ * with a stream interface data layer.
  */
-static inline void si_prepare_conn(struct stream_interface *si, const struct protocol *ctrl, const struct xprt_ops *xprt)
+static inline void si_attach_conn(struct stream_interface *si, struct connection *conn)
 {
-	struct connection *conn = si->conn;
-
 	si->ops = &si_conn_ops;
 	si->end = &conn->obj_type;
-	conn_prepare(conn, ctrl, xprt);
 	conn_attach(conn, si, &si_conn_cb);
 }
 
-static inline void si_prepare_applet(struct stream_interface *si, struct si_applet *applet)
+static inline void si_attach_applet(struct stream_interface *si, struct si_applet *applet)
 {
 	si->ops = &si_embedded_ops;
 	si->appctx.applet = applet;
diff --git a/src/backend.c b/src/backend.c
index 65cbcb6..a06a332 100644
--- a/src/backend.c
+++ b/src/backend.c
@@ -997,17 +997,19 @@ int connect_server(struct session *s)
 
 	/* set the correct protocol on the output stream interface */
 	if (objt_server(s->target)) {
-		si_prepare_conn(s->req->cons, objt_server(s->target)->proto, objt_server(s->target)->xprt);
+		conn_prepare(srv_conn, objt_server(s->target)->proto, objt_server(s->target)->xprt);
 	}
 	else if (obj_type(s->target) == OBJ_TYPE_PROXY) {
 		/* proxies exclusively run on raw_sock right now */
-		si_prepare_conn(s->req->cons, protocol_by_family(srv_conn->addr.to.ss_family), &raw_sock);
+		conn_prepare(srv_conn, protocol_by_family(srv_conn->addr.to.ss_family), &raw_sock);
 		if (!objt_conn(s->req->cons->end) || !objt_conn(s->req->cons->end)->ctrl)
 			return SN_ERR_INTERNAL;
 	}
 	else
 		return SN_ERR_INTERNAL;  /* how did we get there ? */
 
+	si_attach_conn(s->req->cons, srv_conn);
+
 	/* process the case where the server requires the PROXY protocol to be sent */
 	s->req->cons->send_proxy_ofs = 0;
 	if (objt_server(s->target) && (objt_server(s->target)->state & SRV_SEND_PROXY)) {
diff --git a/src/peers.c b/src/peers.c
index 8623704..33f8eaa 100644
--- a/src/peers.c
+++ b/src/peers.c
@@ -1187,7 +1187,8 @@ static struct session *peer_session_create(struct peer *peer, struct peer_sessio
 	 * pre-initialized connection in si->conn.
 	 */
 	conn_init(s->si[1].conn);
-	si_prepare_conn(&s->si[1], peer->proto, peer->xprt);
+	conn_prepare(s->si[1].conn, peer->proto, peer->xprt);
+	si_attach_conn(&s->si[1], s->si[1].conn);
 
 	session_init_srv_conn(s);
 	s->si[1].conn->target = s->target = &s->be->obj_type;
diff --git a/src/session.c b/src/session.c
index f8b29d5..7218dae 100644
--- a/src/session.c
+++ b/src/session.c
@@ -433,7 +433,8 @@ int session_complete(struct session *s)
 		s->si[0].flags |= SI_FL_INDEP_STR;
 
 	s->si[0].conn = conn;
-	si_prepare_conn(&s->si[0], l->proto, l->xprt);
+	conn_prepare(conn, l->proto, l->xprt);
+	si_attach_conn(&s->si[0], conn);
 
 	s->flags |= SN_INITIALIZED;
 	s->unique_id = NULL;
@@ -475,7 +476,7 @@ int session_complete(struct session *s)
 	si_reset(&s->si[1], t);
 	conn_init(s->si[1].conn);
 	s->si[1].conn->target = NULL;
-	si_prepare_none(&s->si[1]);
+	si_detach(&s->si[1]);
 
 	if (likely(s->fe->options2 & PR_O2_INDEPSTR))
 		s->si[1].flags |= SI_FL_INDEP_STR;
diff --git a/src/stream_interface.c b/src/stream_interface.c
index 95f5d44..00b28e6 100644
--- a/src/stream_interface.c
+++ b/src/stream_interface.c
@@ -354,7 +354,7 @@ struct task *stream_int_register_handler(struct stream_interface *si, struct si_
 {
 	DPRINTF(stderr, "registering handler %p for si %p (was %p)\n", app, si, si->owner);
 
-	si_prepare_applet(si, app);
+	si_attach_applet(si, app);
 	si->flags |= SI_FL_WAIT_DATA;
 	return si->owner;
 }
-- 
1.8.1.5

