From 3770f23a3af9ccaf33222fef8dad8966c2d73f72 Mon Sep 17 00:00:00 2001
From: Willy Tarreau <w@1wt.eu>
Date: Sat, 7 Dec 2013 00:01:53 +0100
Subject: [PATCH 269/277] MINOR: http: switch the http state to an enum

This reduces its size which is not reused by anything else. However it
will significantly improve the debugger's output since we'll now get
real state values.

The default case had to be enabled in the parsers because gcc tries
to optimize the switch/case and noticed some values were missing from
the enums and emitted a warning.
---
 include/proto/proto_http.h |   2 +-
 include/types/proto_http.h | 122 ++++++++++++++++++++++-----------------------
 src/proto_http.c           |  21 ++++----
 3 files changed, 72 insertions(+), 73 deletions(-)

diff --git a/include/proto/proto_http.h b/include/proto/proto_http.h
index 97e4652..2075176 100644
--- a/include/proto/proto_http.h
+++ b/include/proto/proto_http.h
@@ -104,7 +104,7 @@ void http_perform_server_redirect(struct session *s, struct stream_interface *si
 void http_return_srv_error(struct session *s, struct stream_interface *si);
 void http_capture_bad_message(struct error_snapshot *es, struct session *s,
                               struct http_msg *msg,
-			      int state, struct proxy *other_end);
+			      enum ht_state state, struct proxy *other_end);
 unsigned int http_get_hdr(const struct http_msg *msg, const char *hname, int hlen,
 			  struct hdr_idx *idx, int occ,
 			  struct hdr_ctx *ctx, char **vptr, int *vlen);
diff --git a/include/types/proto_http.h b/include/types/proto_http.h
index 52c3c70..70c2631 100644
--- a/include/types/proto_http.h
+++ b/include/types/proto_http.h
@@ -117,71 +117,66 @@
  */
 
 /* Possible states while parsing HTTP messages (request|response) */
-#define HTTP_MSG_RQBEFORE      0 // request: leading LF, before start line
-#define HTTP_MSG_RQBEFORE_CR   1 // request: leading CRLF, before start line
-
-/* these ones define a request start line */
-#define HTTP_MSG_RQMETH        2 // parsing the Method
-#define HTTP_MSG_RQMETH_SP     3 // space(s) after the Method
-#define HTTP_MSG_RQURI         4 // parsing the Request URI
-#define HTTP_MSG_RQURI_SP      5 // space(s) after the Request URI
-#define HTTP_MSG_RQVER         6 // parsing the Request Version
-#define HTTP_MSG_RQLINE_END    7 // end of request line (CR or LF)
-
-#define HTTP_MSG_RPBEFORE      8 // response: leading LF, before start line
-#define HTTP_MSG_RPBEFORE_CR   9 // response: leading CRLF, before start line
-
-/* these ones define a response start line */
-#define HTTP_MSG_RPVER        10 // parsing the Response Version
-#define HTTP_MSG_RPVER_SP     11 // space(s) after the Response Version
-#define HTTP_MSG_RPCODE       12 // response code
-#define HTTP_MSG_RPCODE_SP    13 // space(s) after the response code
-#define HTTP_MSG_RPREASON     14 // response reason
-#define HTTP_MSG_RPLINE_END   15 // end of response line (CR or LF)
-
-/* common header processing */
-
-#define HTTP_MSG_HDR_FIRST    16 // waiting for first header or last CRLF (no LWS possible)
-#define HTTP_MSG_HDR_NAME     17 // parsing header name
-#define HTTP_MSG_HDR_COL      18 // parsing header colon
-#define HTTP_MSG_HDR_L1_SP    19 // parsing header LWS (SP|HT) before value
-#define HTTP_MSG_HDR_L1_LF    20 // parsing header LWS (LF) before value
-#define HTTP_MSG_HDR_L1_LWS   21 // checking whether it's a new header or an LWS
-#define HTTP_MSG_HDR_VAL      22 // parsing header value
-#define HTTP_MSG_HDR_L2_LF    23 // parsing header LWS (LF) inside/after value
-#define HTTP_MSG_HDR_L2_LWS   24 // checking whether it's a new header or an LWS
-
-#define HTTP_MSG_LAST_LF      25 // parsing last LF
-
-/* error state : must be before HTTP_MSG_BODY so that (>=BODY) always indicates
- * that data are being processed.
- */
-
-#define HTTP_MSG_ERROR        26 // an error occurred
-
-/* Body processing.
- * The state HTTP_MSG_BODY is a delimiter to know if we're waiting for headers
- * or body. All the sub-states below also indicate we're processing the body,
- * with some additional information.
- */
-#define HTTP_MSG_BODY         27 // parsing body at end of headers
-#define HTTP_MSG_100_SENT     28 // parsing body after a 100-Continue was sent
-#define HTTP_MSG_CHUNK_SIZE   29 // parsing the chunk size (RFC2616 #3.6.1)
-#define HTTP_MSG_DATA         30 // skipping data chunk / content-length data
-#define HTTP_MSG_CHUNK_CRLF   31 // skipping CRLF after data chunk
-#define HTTP_MSG_TRAILERS     32 // trailers (post-data entity headers)
-
-/* we enter this state when we've received the end of the current message */
-#define HTTP_MSG_DONE         33 // message end received, waiting for resync or close
-#define HTTP_MSG_CLOSING      34 // shutdown_w done, not all bytes sent yet
-#define HTTP_MSG_CLOSED       35 // shutdown_w done, all bytes sent
-#define HTTP_MSG_TUNNEL       36 // tunneled data after DONE
-
+enum ht_state {
+	HTTP_MSG_RQBEFORE     =  0, // request: leading LF, before start line
+	HTTP_MSG_RQBEFORE_CR  =  1, // request: leading CRLF, before start line
+	/* these ones define a request start line */
+	HTTP_MSG_RQMETH       =  2, // parsing the Method
+	HTTP_MSG_RQMETH_SP    =  3, // space(s) after the Method
+	HTTP_MSG_RQURI        =  4, // parsing the Request URI
+	HTTP_MSG_RQURI_SP     =  5, // space(s) after the Request URI
+	HTTP_MSG_RQVER        =  6, // parsing the Request Version
+	HTTP_MSG_RQLINE_END   =  7, // end of request line (CR or LF)
+
+	HTTP_MSG_RPBEFORE     =  8, // response: leading LF, before start line
+	HTTP_MSG_RPBEFORE_CR  =  9, // response: leading CRLF, before start line
+
+	/* these ones define a response start line */
+	HTTP_MSG_RPVER        = 10, // parsing the Response Version
+	HTTP_MSG_RPVER_SP     = 11, // space(s) after the Response Version
+	HTTP_MSG_RPCODE       = 12, // response code
+	HTTP_MSG_RPCODE_SP    = 13, // space(s) after the response code
+	HTTP_MSG_RPREASON     = 14, // response reason
+	HTTP_MSG_RPLINE_END   = 15, // end of response line (CR or LF)
+
+	/* common header processing */
+	HTTP_MSG_HDR_FIRST    = 16, // waiting for first header or last CRLF (no LWS possible)
+	HTTP_MSG_HDR_NAME     = 17, // parsing header name
+	HTTP_MSG_HDR_COL      = 18, // parsing header colon
+	HTTP_MSG_HDR_L1_SP    = 19, // parsing header LWS (SP|HT) before value
+	HTTP_MSG_HDR_L1_LF    = 20, // parsing header LWS (LF) before value
+	HTTP_MSG_HDR_L1_LWS   = 21, // checking whether it's a new header or an LWS
+	HTTP_MSG_HDR_VAL      = 22, // parsing header value
+	HTTP_MSG_HDR_L2_LF    = 23, // parsing header LWS (LF) inside/after value
+	HTTP_MSG_HDR_L2_LWS   = 24, // checking whether it's a new header or an LWS
+
+	HTTP_MSG_LAST_LF      = 25, // parsing last LF
+
+	/* error state : must be before HTTP_MSG_BODY so that (>=BODY) always indicates
+	 * that data are being processed.
+	 */
+	HTTP_MSG_ERROR        = 26, // an error occurred
+	/* Body processing.
+	 * The state HTTP_MSG_BODY is a delimiter to know if we're waiting for headers
+	 * or body. All the sub-states below also indicate we're processing the body,
+	 * with some additional information.
+	 */
+	HTTP_MSG_BODY         = 27, // parsing body at end of headers
+	HTTP_MSG_100_SENT     = 28, // parsing body after a 100-Continue was sent
+	HTTP_MSG_CHUNK_SIZE   = 29, // parsing the chunk size (RFC2616 #3.6.1)
+	HTTP_MSG_DATA         = 30, // skipping data chunk / content-length data
+	HTTP_MSG_CHUNK_CRLF   = 31, // skipping CRLF after data chunk
+	HTTP_MSG_TRAILERS     = 32, // trailers (post-data entity headers)
+	/* we enter this state when we've received the end of the current message */
+	HTTP_MSG_DONE         = 33, // message end received, waiting for resync or close
+	HTTP_MSG_CLOSING      = 34, // shutdown_w done, not all bytes sent yet
+	HTTP_MSG_CLOSED       = 35, // shutdown_w done, all bytes sent
+	HTTP_MSG_TUNNEL       = 36, // tunneled data after DONE
+} __attribute__((packed));
 
 /*
  * HTTP message status flags (msg->flags)
  */
-
 #define HTTP_MSGF_CNT_LEN     0x00000001  /* content-length was found in the message */
 #define HTTP_MSGF_TE_CHNK     0x00000002  /* transfer-encoding: chunked was found */
 
@@ -329,8 +324,9 @@ enum {
  * care for wrapping (no addition overflow nor subtract underflow).
  */
 struct http_msg {
-	unsigned int msg_state;                /* where we are in the current message parsing */
-	unsigned int flags;                    /* flags describing the message (HTTP version, ...) */
+	enum ht_state msg_state;               /* where we are in the current message parsing */
+	unsigned char flags;                   /* flags describing the message (HTTP version, ...) */
+	/* 6 bytes unused here */
 	struct channel *chn;                   /* pointer to the channel transporting the message */
 	unsigned int next;                     /* pointer to next byte to parse, relative to buf->p */
 	unsigned int sov;                      /* current header: start of value */
diff --git a/src/proto_http.c b/src/proto_http.c
index c8705d4..a7e42fc 100644
--- a/src/proto_http.c
+++ b/src/proto_http.c
@@ -1038,8 +1038,8 @@ void capture_headers(char *som, struct hdr_idx *idx,
  * labels and variable names. Note that msg->sol is left unchanged.
  */
 const char *http_parse_stsline(struct http_msg *msg,
-			       unsigned int state, const char *ptr, const char *end,
-			       unsigned int *ret_ptr, unsigned int *ret_state)
+			       enum ht_state state, const char *ptr, const char *end,
+			       unsigned int *ret_ptr, enum ht_state *ret_state)
 {
 	const char *msg_start = msg->chn->buf->p;
 
@@ -1112,11 +1112,12 @@ const char *http_parse_stsline(struct http_msg *msg,
 		msg->sl.st.l = ptr - msg_start - msg->sol;
 		return ptr;
 
-#ifdef DEBUG_FULL
 	default:
+#ifdef DEBUG_FULL
 		fprintf(stderr, "FIXME !!!! impossible state at %s:%d = %d\n", __FILE__, __LINE__, state);
 		exit(1);
 #endif
+		;
 	}
 
  http_msg_ood:
@@ -1148,8 +1149,8 @@ const char *http_parse_stsline(struct http_msg *msg,
  * labels and variable names. Note that msg->sol is left unchanged.
  */
 const char *http_parse_reqline(struct http_msg *msg,
-			       unsigned int state, const char *ptr, const char *end,
-			       unsigned int *ret_ptr, unsigned int *ret_state)
+			       enum ht_state state, const char *ptr, const char *end,
+			       unsigned int *ret_ptr, enum ht_state *ret_state)
 {
 	const char *msg_start = msg->chn->buf->p;
 
@@ -1256,11 +1257,12 @@ const char *http_parse_reqline(struct http_msg *msg,
 		state = HTTP_MSG_ERROR;
 		break;
 
-#ifdef DEBUG_FULL
 	default:
+#ifdef DEBUG_FULL
 		fprintf(stderr, "FIXME !!!! impossible state at %s:%d = %d\n", __FILE__, __LINE__, state);
 		exit(1);
 #endif
+		;
 	}
 
  http_msg_ood:
@@ -1367,7 +1369,7 @@ get_http_auth(struct session *s)
  */
 void http_msg_analyzer(struct http_msg *msg, struct hdr_idx *idx)
 {
-	unsigned int state;       /* updated only when leaving the FSM */
+	enum ht_state state;       /* updated only when leaving the FSM */
 	register char *ptr, *end; /* request pointers, to avoid dereferences */
 	struct buffer *buf;
 
@@ -1650,11 +1652,12 @@ void http_msg_analyzer(struct http_msg *msg, struct hdr_idx *idx)
 		/* this may only happen if we call http_msg_analyser() twice with an error */
 		break;
 
-#ifdef DEBUG_FULL
 	default:
+#ifdef DEBUG_FULL
 		fprintf(stderr, "FIXME !!!! impossible state at %s:%d = %d\n", __FILE__, __LINE__, state);
 		exit(1);
 #endif
+		;
 	}
  http_msg_ood:
 	/* out of data */
@@ -7795,7 +7798,7 @@ int stats_check_uri(struct stream_interface *si, struct http_txn *txn, struct pr
  */
 void http_capture_bad_message(struct error_snapshot *es, struct session *s,
                               struct http_msg *msg,
-			      int state, struct proxy *other_end)
+			      enum ht_state state, struct proxy *other_end)
 {
 	struct channel *chn = msg->chn;
 	int len1, len2;
-- 
1.8.1.5

