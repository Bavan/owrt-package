From 9f68148321985852336796ca32da1ba8a0095eb8 Mon Sep 17 00:00:00 2001
From: Willy Tarreau <w@1wt.eu>
Date: Mon, 8 Jul 2013 16:05:07 +0200
Subject: [PATCH 210/277] MEDIUM: peers: don't rely on conn->xprt_ctx anymore

We make the peers code use applet->ptr instead of conn->xprt_ctx to
store the pointer to the current peer. That way it does not depend
on a connection anymore.
---
 include/types/stream_interface.h |  1 +
 src/peers.c                      | 40 +++++++++++++++++++---------------------
 2 files changed, 20 insertions(+), 21 deletions(-)

diff --git a/include/types/stream_interface.h b/include/types/stream_interface.h
index 5ce65a6..6748fbf 100644
--- a/include/types/stream_interface.h
+++ b/include/types/stream_interface.h
@@ -120,6 +120,7 @@ struct stream_interface {
 		unsigned int st0;     /* CLI state for stats, session state for peers */
 		unsigned int st1;     /* prompt for stats, session error for peers */
 		unsigned int st2;     /* output state for stats, unused by peers  */
+		void *ptr;            /* struct peer for peers */
 
 		union {
 			struct {
diff --git a/src/peers.c b/src/peers.c
index 0ed4b85..04385ac 100644
--- a/src/peers.c
+++ b/src/peers.c
@@ -183,11 +183,10 @@ static int peer_prepare_datamsg(struct stksess *ts, struct peer_session *ps, cha
  */
 static void peer_session_release(struct stream_interface *si)
 {
-	struct task *t = (struct task *)si->owner;
-	struct session *s = (struct session *)t->context;
-	struct peer_session *ps = (struct peer_session *)si->conn->xprt_ctx;
+	struct session *s = session_from_task(si->owner);
+	struct peer_session *ps = (struct peer_session *)si->applet.ptr;
 
-	/* si->conn->xprt_ctx is not a peer session */
+	/* si->applet.ptr is not a peer session */
 	if (si->applet.st0 < PEER_SESSION_SENDSUCCESS)
 		return;
 
@@ -217,8 +216,7 @@ static void peer_session_release(struct stream_interface *si)
  */
 static void peer_io_handler(struct stream_interface *si)
 {
-	struct task *t= (struct task *)si->owner;
-	struct session *s = (struct session *)t->context;
+	struct session *s = session_from_task(si->owner);
 	struct peers *curpeers = (struct peers *)s->fe->parent;
 	int reql = 0;
 	int repl = 0;
@@ -227,7 +225,7 @@ static void peer_io_handler(struct stream_interface *si)
 switchstate:
 		switch(si->applet.st0) {
 			case PEER_SESSION_ACCEPT:
-				si->conn->xprt_ctx = NULL;
+				si->applet.ptr = NULL;
 				si->applet.st0 = PEER_SESSION_GETVERSION;
 				/* fall through */
 			case PEER_SESSION_GETVERSION:
@@ -333,12 +331,12 @@ switchstate:
 					goto switchstate;
 				}
 
-				si->conn->xprt_ctx = curpeer;
+				si->applet.ptr = curpeer;
 				si->applet.st0 = PEER_SESSION_GETTABLE;
 				/* fall through */
 			}
 			case PEER_SESSION_GETTABLE: {
-				struct peer *curpeer = (struct peer *)si->conn->xprt_ctx;
+				struct peer *curpeer = (struct peer *)si->applet.ptr;
 				struct shared_table *st;
 				struct peer_session *ps = NULL;
 				unsigned long key_type;
@@ -349,12 +347,12 @@ switchstate:
 				if (reql <= 0) { /* closed or EOL not found */
 					if (reql == 0)
 						goto out;
-					si->conn->xprt_ctx = NULL;
+					si->applet.ptr = NULL;
 					si->applet.st0 = PEER_SESSION_END;
 					goto switchstate;
 				}
-				/* Re init si->conn->xprt_ctx to null, to handle correctly a release case */
-				si->conn->xprt_ctx = NULL;
+				/* Re init si->applet.ptr to null, to handle correctly a release case */
+				si->applet.ptr = NULL;
 
 				if (trash.str[reql-1] != '\n') {
 					/* Incomplete line, we quit */
@@ -380,7 +378,7 @@ switchstate:
 
 				p = strchr(p+1, ' ');
 				if (!p) {
-					si->conn->xprt_ctx = NULL;
+					si->applet.ptr = NULL;
 					si->applet.st0 = PEER_SESSION_EXIT;
 					si->applet.st1 = PEER_SESSION_ERRPROTO;
 					goto switchstate;
@@ -444,12 +442,12 @@ switchstate:
 					goto switchstate;
 				}
 
-				si->conn->xprt_ctx = ps;
+				si->applet.ptr = ps;
 				si->applet.st0 = PEER_SESSION_SENDSUCCESS;
 				/* fall through */
 			}
 			case PEER_SESSION_SENDSUCCESS:{
-				struct peer_session *ps = (struct peer_session *)si->conn->xprt_ctx;
+				struct peer_session *ps = (struct peer_session *)si->applet.ptr;
 
 				repl = snprintf(trash.str, trash.size, "%d\n", PEER_SESSION_SUCCESSCODE);
 				repl = bi_putblk(si->ib, trash.str, repl);
@@ -499,7 +497,7 @@ switchstate:
 				goto switchstate;
 			}
 			case PEER_SESSION_CONNECT: {
-				struct peer_session *ps = (struct peer_session *)si->conn->xprt_ctx;
+				struct peer_session *ps = (struct peer_session *)si->applet.ptr;
 
 				/* Send headers */
 				repl = snprintf(trash.str, trash.size,
@@ -529,7 +527,7 @@ switchstate:
 				/* fall through */
 			}
 			case PEER_SESSION_GETSTATUS: {
-				struct peer_session *ps = (struct peer_session *)si->conn->xprt_ctx;
+				struct peer_session *ps = (struct peer_session *)si->applet.ptr;
 
 				if (si->ib->flags & CF_WRITE_PARTIAL)
 					ps->statuscode = PEER_SESSION_CONNECTEDCODE;
@@ -600,7 +598,7 @@ switchstate:
 				/* fall through */
 			}
 			case PEER_SESSION_WAITMSG: {
-				struct peer_session *ps = (struct peer_session *)si->conn->xprt_ctx;
+				struct peer_session *ps = (struct peer_session *)si->applet.ptr;
 				struct stksess *ts, *newts = NULL;
 				char c;
 				int totl = 0;
@@ -1074,7 +1072,7 @@ static void peer_session_forceshutdown(struct session * session)
 	/* call release to reinit resync states if needed */
 	peer_session_release(oldsi);
 	oldsi->applet.st0 = PEER_SESSION_END;
-	oldsi->conn->xprt_ctx = NULL;
+	oldsi->applet.ptr = NULL;
 	task_wakeup(session->task, TASK_WOKEN_MSG);
 }
 
@@ -1089,7 +1087,7 @@ int peer_accept(struct session *s)
 	 /* we have a dedicated I/O handler for the stats */
 	stream_int_register_handler(&s->si[1], &peer_applet);
 	s->target = s->si[1].conn->target; // for logging only
-	s->si[1].conn->xprt_ctx = s;
+	s->si[1].applet.ptr = s;
 	s->si[1].applet.st0 = PEER_SESSION_ACCEPT;
 
 	tv_zero(&s->logs.tv_request);
@@ -1180,7 +1178,7 @@ static struct session *peer_session_create(struct peer *peer, struct peer_sessio
 
 	stream_int_register_handler(&s->si[0], &peer_applet);
 	s->si[0].applet.st0 = PEER_SESSION_CONNECT;
-	s->si[0].conn->xprt_ctx = (void *)ps;
+	s->si[0].applet.ptr = (void *)ps;
 
 	s->si[1].conn->t.sock.fd = -1; /* just to help with debugging */
 	s->si[1].conn->flags = CO_FL_NONE;
-- 
1.8.1.5

