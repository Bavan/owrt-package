From 4a59f2f954c9ab88eefb023bf95fb1a3ad226a57 Mon Sep 17 00:00:00 2001
From: Willy Tarreau <w@1wt.eu>
Date: Thu, 24 Oct 2013 20:10:45 +0200
Subject: [PATCH 231/277] MAJOR: stream interface: remove the ->release
 function pointer

Since last commit, we now have a pointer to the applet in the
applet context. So we don't need the si->release function pointer
anymore, it can be extracted from applet->applet.release. At many
places, the ->release function was still tested for real connections
while it is only limited to applets, so most of them were simply
removed. For the remaining valid uses, a new inline function
si_applet_release() was added to simplify the check and the call.
---
 include/proto/stream_interface.h | 16 ++++++++++++++++
 include/types/stream_interface.h |  2 --
 src/peers.c                      |  2 --
 src/session.c                    |  5 -----
 src/stream_interface.c           | 19 +++----------------
 5 files changed, 19 insertions(+), 25 deletions(-)

diff --git a/include/proto/stream_interface.h b/include/proto/stream_interface.h
index 26e9bfa..507a6d1 100644
--- a/include/proto/stream_interface.h
+++ b/include/proto/stream_interface.h
@@ -83,6 +83,22 @@ static inline void si_prepare_applet(struct stream_interface *si, struct si_appl
 	si->appctx.applet = applet;
 }
 
+/* returns a pointer to the applet being run in the SI or NULL if none */
+static inline const struct si_applet *si_applet(struct stream_interface *si)
+{
+	return objt_applet(si->conn->target);
+}
+
+/* call the applet's release function if any. Needs to be called upon close() */
+static inline void si_applet_release(struct stream_interface *si)
+{
+	const struct si_applet *applet;
+
+	applet = si_applet(si);
+	if (applet && applet->release)
+		applet->release(si);
+}
+
 /* Sends a shutr to the connection using the data layer */
 static inline void si_shutr(struct stream_interface *si)
 {
diff --git a/include/types/stream_interface.h b/include/types/stream_interface.h
index 588f4c4..0862c90 100644
--- a/include/types/stream_interface.h
+++ b/include/types/stream_interface.h
@@ -167,8 +167,6 @@ struct stream_interface {
 	struct connection *conn; /* descriptor for a connection */
 	struct si_ops *ops;     /* general operations at the stream interface layer */
 
-	void (*release)(struct stream_interface *); /* handler to call after the last close() */
-
 	/* struct members below are the "remote" part, as seen from the buffer side */
 	int conn_retries;	/* number of connect retries left */
 	int send_proxy_ofs;	/* <0 = offset to (re)send from the end, >0 = send all */
diff --git a/src/peers.c b/src/peers.c
index 43d7249..9797671 100644
--- a/src/peers.c
+++ b/src/peers.c
@@ -1169,7 +1169,6 @@ static struct session *peer_session_create(struct peer *peer, struct peer_sessio
 	s->si[0].owner = t;
 	s->si[0].state = s->si[0].prev_state = SI_ST_EST;
 	s->si[0].err_type = SI_ET_NONE;
-	s->si[0].release = NULL;
 	s->si[0].send_proxy_ofs = 0;
 	s->si[0].conn->target = &l->obj_type;
 	s->si[0].exp = TICK_ETERNITY;
@@ -1189,7 +1188,6 @@ static struct session *peer_session_create(struct peer *peer, struct peer_sessio
 	s->si[1].state = s->si[1].prev_state = SI_ST_ASS;
 	s->si[1].conn_retries = p->conn_retries;
 	s->si[1].err_type = SI_ET_NONE;
-	s->si[1].release = NULL;
 	s->si[1].send_proxy_ofs = 0;
 	s->si[1].conn->target = &s->be->obj_type;
 	si_prepare_conn(&s->si[1], peer->proto, peer->xprt);
diff --git a/src/session.c b/src/session.c
index 0f626cd..c86df3c 100644
--- a/src/session.c
+++ b/src/session.c
@@ -448,7 +448,6 @@ int session_complete(struct session *s)
 	s->si[0].owner     = t;
 	s->si[0].state     = s->si[0].prev_state = SI_ST_EST;
 	s->si[0].err_type  = SI_ET_NONE;
-	s->si[0].release   = NULL;
 	s->si[0].send_proxy_ofs = 0;
 	s->si[0].exp       = TICK_ETERNITY;
 	s->si[0].flags     = SI_FL_NONE;
@@ -467,7 +466,6 @@ int session_complete(struct session *s)
 	s->si[1].state     = s->si[1].prev_state = SI_ST_INI;
 	s->si[1].err_type  = SI_ET_NONE;
 	s->si[1].conn_retries = 0;  /* used for logging too */
-	s->si[1].release   = NULL;
 	s->si[1].send_proxy_ofs = 0;
 	si_prepare_none(&s->si[1]);
 	s->si[1].exp       = TICK_ETERNITY;
@@ -803,9 +801,6 @@ static int sess_update_st_con_tcp(struct session *s, struct stream_interface *si
 		si->conn->flags &= ~CO_FL_XPRT_TRACKED;
 		conn_full_close(si->conn);
 
-		if (si->release)
-			si->release(si);
-
 		if (si->err_type)
 			return 0;
 
diff --git a/src/stream_interface.c b/src/stream_interface.c
index 55342e7..4f62e2d 100644
--- a/src/stream_interface.c
+++ b/src/stream_interface.c
@@ -230,9 +230,7 @@ static void stream_int_shutr(struct stream_interface *si)
 	if (si->ob->flags & CF_SHUTW) {
 		si->state = SI_ST_DIS;
 		si->exp = TICK_ETERNITY;
-
-		if (si->release)
-			si->release(si);
+		si_applet_release(si);
 	}
 	else if (si->flags & SI_FL_NOHALF) {
 		/* we want to immediately forward this close to the write side */
@@ -279,9 +277,7 @@ static void stream_int_shutw(struct stream_interface *si)
 	case SI_ST_TAR:
 		/* Note that none of these states may happen with applets */
 		si->state = SI_ST_DIS;
-
-		if (si->release)
-			si->release(si);
+		si_applet_release(si);
 	default:
 		si->flags &= ~(SI_FL_WAIT_ROOM | SI_FL_NOLINGER);
 		si->ib->flags &= ~CF_SHUTR_NOW;
@@ -359,7 +355,6 @@ struct task *stream_int_register_handler(struct stream_interface *si, struct si_
 	DPRINTF(stderr, "registering handler %p for si %p (was %p)\n", app, si, si->owner);
 
 	si_prepare_applet(si, app);
-	si->release = app->release;
 	si->flags |= SI_FL_WAIT_DATA;
 	return si->owner;
 }
@@ -369,7 +364,6 @@ struct task *stream_int_register_handler(struct stream_interface *si, struct si_
  */
 void stream_int_unregister_handler(struct stream_interface *si)
 {
-	si->release = NULL;
 	si->owner = NULL;
 	si->conn->target = NULL;
 	si->end = NULL;
@@ -735,9 +729,6 @@ static void stream_int_shutr_conn(struct stream_interface *si)
 		conn_full_close(conn);
 		si->state = SI_ST_DIS;
 		si->exp = TICK_ETERNITY;
-
-		if (si->release)
-			si->release(si);
 	}
 	else if (si->flags & SI_FL_NOHALF) {
 		/* we want to immediately forward this close to the write side */
@@ -831,9 +822,7 @@ static void stream_int_shutw_conn(struct stream_interface *si)
 	case SI_ST_QUE:
 	case SI_ST_TAR:
 		si->state = SI_ST_DIS;
-
-		if (si->release)
-			si->release(si);
+		/* fall through */
 	default:
 		si->flags &= ~(SI_FL_WAIT_ROOM | SI_FL_NOLINGER);
 		si->ib->flags &= ~CF_SHUTR_NOW;
@@ -1287,8 +1276,6 @@ void stream_sock_read0(struct stream_interface *si)
 
 	si->state = SI_ST_DIS;
 	si->exp = TICK_ETERNITY;
-	if (si->release)
-		si->release(si);
 	return;
 }
 
-- 
1.8.1.5

