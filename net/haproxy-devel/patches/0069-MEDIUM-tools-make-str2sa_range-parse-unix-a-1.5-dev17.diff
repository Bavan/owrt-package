From 1558638aafe97cb80bbe35c05afc681a07323536 Mon Sep 17 00:00:00 2001
From: Willy Tarreau <w@1wt.eu>
Date: Mon, 4 Mar 2013 19:48:14 +0100
Subject: MEDIUM: tools: make str2sa_range() parse unix addresses too

str2sa_range() now considers that any address beginning with '/' is a UNIX
address. It is compatible with all callers at the moment since all of them
perform this test and use a different parser for such addresses. However,
some parsers (eg: servers) still don't check for unix addresses.
---
 src/standard.c |   31 +++++++++++++++++++++++++++++++
 1 files changed, 31 insertions(+), 0 deletions(-)

diff --git a/src/standard.c b/src/standard.c
index 08af648..833d91a 100644
--- a/src/standard.c
+++ b/src/standard.c
@@ -656,6 +656,37 @@ struct sockaddr_storage *str2sa_range(const char *str, int *low, int *high, char
 		goto out;
 	}
 
+	if (*str2 == '/') {
+		/* unix socket */
+		static struct sockaddr_storage ss;
+		int prefix_path_len;
+		int max_path_len;
+
+		/* complete unix socket path name during startup or soft-restart is
+		 * <unix_bind_prefix><path>.<pid>.<bak|tmp>
+		 */
+		prefix_path_len = pfx ? strlen(pfx) : 0;
+		max_path_len = (sizeof(((struct sockaddr_un *)&ss)->sun_path) - 1) -
+			(prefix_path_len ? prefix_path_len + 1 + 5 + 1 + 3 : 0);
+
+		if (strlen(str2) > max_path_len) {
+			memprintf(err, "socket path '%s' too long (max %d)\n", str, max_path_len);
+			goto out;
+		}
+
+		memset(&ss, 0, sizeof(ss));
+		ss.ss_family = AF_UNIX;
+		if (pfx) {
+			memcpy(((struct sockaddr_un *)&ss)->sun_path, pfx, prefix_path_len);
+			strcpy(((struct sockaddr_un *)&ss)->sun_path + prefix_path_len, str2);
+		}
+		else {
+			strcpy(((struct sockaddr_un *)&ss)->sun_path, str2);
+		}
+		ret = &ss;
+		goto out;
+	}
+
 	port1 = strrchr(str2, ':');
 	if (port1)
 		*port1++ = '\0';
-- 
1.7.1

