From 9b6c2c721e695968dde0db4463c4b7d230590d10 Mon Sep 17 00:00:00 2001
From: Willy Tarreau <w@1wt.eu>
Date: Sun, 24 Nov 2013 09:38:33 +0100
Subject: [PATCH 227/277] MINOR: stream-int: rename ->applet to ->appctx

Since this is the applet context, call it ->appctx to avoid the confusion
with the pointer to the applet. Many places were changed but it's only a
renaming.
---
 include/types/stream_interface.h |   2 +-
 src/dumpstats.c                  | 930 +++++++++++++++++++--------------------
 src/peers.c                      | 158 +++----
 src/proto_http.c                 |  44 +-
 4 files changed, 567 insertions(+), 567 deletions(-)

diff --git a/include/types/stream_interface.h b/include/types/stream_interface.h
index 1af5be5..b7f1a5a 100644
--- a/include/types/stream_interface.h
+++ b/include/types/stream_interface.h
@@ -169,7 +169,7 @@ struct stream_interface {
 	/* struct members below are the "remote" part, as seen from the buffer side */
 	int conn_retries;	/* number of connect retries left */
 	int send_proxy_ofs;	/* <0 = offset to (re)send from the end, >0 = send all */
-	struct appctx applet;   /* context of the running applet if any */
+	struct appctx appctx;   /* context of the running applet if any */
 };
 
 /* An applet designed to run in a stream interface */
diff --git a/src/dumpstats.c b/src/dumpstats.c
index 2332379..5e54d5d 100644
--- a/src/dumpstats.c
+++ b/src/dumpstats.c
@@ -159,8 +159,8 @@ static int stats_accept(struct session *s)
 	/* we have a dedicated I/O handler for the stats */
 	stream_int_register_handler(&s->si[1], &cli_applet);
 	s->target = s->si[1].conn->target; // for logging only
-	s->si[1].applet.st1 = 0;
-	s->si[1].applet.st0 = STAT_CLI_INIT;
+	s->si[1].appctx.st1 = 0;
+	s->si[1].appctx.st0 = STAT_CLI_INIT;
 
 	tv_zero(&s->logs.tv_request);
 	s->logs.t_queue = 0;
@@ -583,7 +583,7 @@ static int stats_dump_table_entry_to_buffer(struct chunk *msg, struct stream_int
 static void stats_sock_table_key_request(struct stream_interface *si, char **args, int action)
 {
 	struct session *s = session_from_task(si->owner);
-	struct proxy *px = si->applet.ctx.table.target;
+	struct proxy *px = si->appctx.ctx.table.target;
 	struct stksess *ts;
 	uint32_t uint32_key;
 	unsigned char ip6_key[sizeof(struct in6_addr)];
@@ -593,11 +593,11 @@ static void stats_sock_table_key_request(struct stream_interface *si, char **arg
 	void *ptr;
 	struct freq_ctr_period *frqp;
 
-	si->applet.st0 = STAT_CLI_OUTPUT;
+	si->appctx.st0 = STAT_CLI_OUTPUT;
 
 	if (!*args[4]) {
-		si->applet.ctx.cli.msg = "Key value expected\n";
-		si->applet.st0 = STAT_CLI_PRINT;
+		si->appctx.ctx.cli.msg = "Key value expected\n";
+		si->appctx.st0 = STAT_CLI_PRINT;
 		return;
 	}
 
@@ -619,8 +619,8 @@ static void stats_sock_table_key_request(struct stream_interface *si, char **arg
 			if ((errno == ERANGE && val == ULONG_MAX) ||
 			    (errno != 0 && val == 0) || endptr == args[4] ||
 			    val > 0xffffffff) {
-				si->applet.ctx.cli.msg = "Invalid key\n";
-				si->applet.st0 = STAT_CLI_PRINT;
+				si->appctx.ctx.cli.msg = "Invalid key\n";
+				si->appctx.st0 = STAT_CLI_PRINT;
 				return;
 			}
 			uint32_key = (uint32_t) val;
@@ -635,23 +635,23 @@ static void stats_sock_table_key_request(struct stream_interface *si, char **arg
 	default:
 		switch (action) {
 		case STAT_CLI_O_TAB:
-			si->applet.ctx.cli.msg = "Showing keys from tables of type other than ip, ipv6, string and integer is not supported\n";
+			si->appctx.ctx.cli.msg = "Showing keys from tables of type other than ip, ipv6, string and integer is not supported\n";
 			break;
 		case STAT_CLI_O_CLR:
-			si->applet.ctx.cli.msg = "Removing keys from ip tables of type other than ip, ipv6, string and integer is not supported\n";
+			si->appctx.ctx.cli.msg = "Removing keys from ip tables of type other than ip, ipv6, string and integer is not supported\n";
 			break;
 		default:
-			si->applet.ctx.cli.msg = "Unknown action\n";
+			si->appctx.ctx.cli.msg = "Unknown action\n";
 			break;
 		}
-		si->applet.st0 = STAT_CLI_PRINT;
+		si->appctx.st0 = STAT_CLI_PRINT;
 		return;
 	}
 
 	/* check permissions */
 	if (s->listener->bind_conf->level < ACCESS_LVL_OPER) {
-		si->applet.ctx.cli.msg = stats_permission_denied_msg;
-		si->applet.st0 = STAT_CLI_PRINT;
+		si->appctx.ctx.cli.msg = stats_permission_denied_msg;
+		si->appctx.st0 = STAT_CLI_PRINT;
 		return;
 	}
 
@@ -672,8 +672,8 @@ static void stats_sock_table_key_request(struct stream_interface *si, char **arg
 			return;
 		if (ts->ref_cnt) {
 			/* don't delete an entry which is currently referenced */
-			si->applet.ctx.cli.msg = "Entry currently in use, cannot remove\n";
-			si->applet.st0 = STAT_CLI_PRINT;
+			si->appctx.ctx.cli.msg = "Entry currently in use, cannot remove\n";
+			si->appctx.st0 = STAT_CLI_PRINT;
 			return;
 		}
 		stksess_kill(&px->table, ts);
@@ -686,8 +686,8 @@ static void stats_sock_table_key_request(struct stream_interface *si, char **arg
 			ts = stksess_new(&px->table, static_table_key);
 			if (!ts) {
 				/* don't delete an entry which is currently referenced */
-				si->applet.ctx.cli.msg = "Unable to allocate a new entry\n";
-				si->applet.st0 = STAT_CLI_PRINT;
+				si->appctx.ctx.cli.msg = "Unable to allocate a new entry\n";
+				si->appctx.st0 = STAT_CLI_PRINT;
 				return;
 			}
 			stktable_store(&px->table, ts, 1);
@@ -695,27 +695,27 @@ static void stats_sock_table_key_request(struct stream_interface *si, char **arg
 
 		for (cur_arg = 5; *args[cur_arg]; cur_arg += 2) {
 			if (strncmp(args[cur_arg], "data.", 5) != 0) {
-				si->applet.ctx.cli.msg = "\"data.<type>\" followed by a value expected\n";
-				si->applet.st0 = STAT_CLI_PRINT;
+				si->appctx.ctx.cli.msg = "\"data.<type>\" followed by a value expected\n";
+				si->appctx.st0 = STAT_CLI_PRINT;
 				return;
 			}
 
 			data_type = stktable_get_data_type(args[cur_arg] + 5);
 			if (data_type < 0) {
-				si->applet.ctx.cli.msg = "Unknown data type\n";
-				si->applet.st0 = STAT_CLI_PRINT;
+				si->appctx.ctx.cli.msg = "Unknown data type\n";
+				si->appctx.st0 = STAT_CLI_PRINT;
 				return;
 			}
 
 			if (!px->table.data_ofs[data_type]) {
-				si->applet.ctx.cli.msg = "Data type not stored in this table\n";
-				si->applet.st0 = STAT_CLI_PRINT;
+				si->appctx.ctx.cli.msg = "Data type not stored in this table\n";
+				si->appctx.st0 = STAT_CLI_PRINT;
 				return;
 			}
 
 			if (!*args[cur_arg+1] || strl2llrc(args[cur_arg+1], strlen(args[cur_arg+1]), &value) != 0) {
-				si->applet.ctx.cli.msg = "Require a valid integer value to store\n";
-				si->applet.st0 = STAT_CLI_PRINT;
+				si->appctx.ctx.cli.msg = "Require a valid integer value to store\n";
+				si->appctx.st0 = STAT_CLI_PRINT;
 				return;
 			}
 
@@ -747,8 +747,8 @@ static void stats_sock_table_key_request(struct stream_interface *si, char **arg
 		break;
 
 	default:
-		si->applet.ctx.cli.msg = "Unknown action\n";
-		si->applet.st0 = STAT_CLI_PRINT;
+		si->appctx.ctx.cli.msg = "Unknown action\n";
+		si->appctx.st0 = STAT_CLI_PRINT;
 		break;
 	}
 }
@@ -756,53 +756,53 @@ static void stats_sock_table_key_request(struct stream_interface *si, char **arg
 static void stats_sock_table_data_request(struct stream_interface *si, char **args, int action)
 {
 	if (action != STAT_CLI_O_TAB && action != STAT_CLI_O_CLR) {
-		si->applet.ctx.cli.msg = "content-based lookup is only supported with the \"show\" and \"clear\" actions";
-		si->applet.st0 = STAT_CLI_PRINT;
+		si->appctx.ctx.cli.msg = "content-based lookup is only supported with the \"show\" and \"clear\" actions";
+		si->appctx.st0 = STAT_CLI_PRINT;
 		return;
 	}
 
 	/* condition on stored data value */
-	si->applet.ctx.table.data_type = stktable_get_data_type(args[3] + 5);
-	if (si->applet.ctx.table.data_type < 0) {
-		si->applet.ctx.cli.msg = "Unknown data type\n";
-		si->applet.st0 = STAT_CLI_PRINT;
+	si->appctx.ctx.table.data_type = stktable_get_data_type(args[3] + 5);
+	if (si->appctx.ctx.table.data_type < 0) {
+		si->appctx.ctx.cli.msg = "Unknown data type\n";
+		si->appctx.st0 = STAT_CLI_PRINT;
 		return;
 	}
 
-	if (!((struct proxy *)si->applet.ctx.table.target)->table.data_ofs[si->applet.ctx.table.data_type]) {
-		si->applet.ctx.cli.msg = "Data type not stored in this table\n";
-		si->applet.st0 = STAT_CLI_PRINT;
+	if (!((struct proxy *)si->appctx.ctx.table.target)->table.data_ofs[si->appctx.ctx.table.data_type]) {
+		si->appctx.ctx.cli.msg = "Data type not stored in this table\n";
+		si->appctx.st0 = STAT_CLI_PRINT;
 		return;
 	}
 
-	si->applet.ctx.table.data_op = get_std_op(args[4]);
-	if (si->applet.ctx.table.data_op < 0) {
-		si->applet.ctx.cli.msg = "Require and operator among \"eq\", \"ne\", \"le\", \"ge\", \"lt\", \"gt\"\n";
-		si->applet.st0 = STAT_CLI_PRINT;
+	si->appctx.ctx.table.data_op = get_std_op(args[4]);
+	if (si->appctx.ctx.table.data_op < 0) {
+		si->appctx.ctx.cli.msg = "Require and operator among \"eq\", \"ne\", \"le\", \"ge\", \"lt\", \"gt\"\n";
+		si->appctx.st0 = STAT_CLI_PRINT;
 		return;
 	}
 
-	if (!*args[5] || strl2llrc(args[5], strlen(args[5]), &si->applet.ctx.table.value) != 0) {
-		si->applet.ctx.cli.msg = "Require a valid integer value to compare against\n";
-		si->applet.st0 = STAT_CLI_PRINT;
+	if (!*args[5] || strl2llrc(args[5], strlen(args[5]), &si->appctx.ctx.table.value) != 0) {
+		si->appctx.ctx.cli.msg = "Require a valid integer value to compare against\n";
+		si->appctx.st0 = STAT_CLI_PRINT;
 		return;
 	}
 }
 
 static void stats_sock_table_request(struct stream_interface *si, char **args, int action)
 {
-	si->applet.ctx.table.data_type = -1;
-	si->applet.st2 = STAT_ST_INIT;
-	si->applet.ctx.table.target = NULL;
-	si->applet.ctx.table.proxy = NULL;
-	si->applet.ctx.table.entry = NULL;
-	si->applet.st0 = action;
+	si->appctx.ctx.table.data_type = -1;
+	si->appctx.st2 = STAT_ST_INIT;
+	si->appctx.ctx.table.target = NULL;
+	si->appctx.ctx.table.proxy = NULL;
+	si->appctx.ctx.table.entry = NULL;
+	si->appctx.st0 = action;
 
 	if (*args[2]) {
-		si->applet.ctx.table.target = find_stktable(args[2]);
-		if (!si->applet.ctx.table.target) {
-			si->applet.ctx.cli.msg = "No such table\n";
-			si->applet.st0 = STAT_CLI_PRINT;
+		si->appctx.ctx.table.target = find_stktable(args[2]);
+		if (!si->appctx.ctx.table.target) {
+			si->appctx.ctx.cli.msg = "No such table\n";
+			si->appctx.st0 = STAT_CLI_PRINT;
 			return;
 		}
 	}
@@ -824,16 +824,16 @@ static void stats_sock_table_request(struct stream_interface *si, char **args, i
 err_args:
 	switch (action) {
 	case STAT_CLI_O_TAB:
-		si->applet.ctx.cli.msg = "Optional argument only supports \"data.<store_data_type>\" <operator> <value> and key <key>\n";
+		si->appctx.ctx.cli.msg = "Optional argument only supports \"data.<store_data_type>\" <operator> <value> and key <key>\n";
 		break;
 	case STAT_CLI_O_CLR:
-		si->applet.ctx.cli.msg = "Required arguments: <table> \"data.<store_data_type>\" <operator> <value> or <table> key <key>\n";
+		si->appctx.ctx.cli.msg = "Required arguments: <table> \"data.<store_data_type>\" <operator> <value> or <table> key <key>\n";
 		break;
 	default:
-		si->applet.ctx.cli.msg = "Unknown action\n";
+		si->appctx.ctx.cli.msg = "Unknown action\n";
 		break;
 	}
-	si->applet.st0 = STAT_CLI_PRINT;
+	si->appctx.st0 = STAT_CLI_PRINT;
 }
 
 /* Expects to find a frontend named <arg> and returns it, otherwise displays various
@@ -845,21 +845,21 @@ static struct proxy *expect_frontend_admin(struct session *s, struct stream_inte
 	struct proxy *px;
 
 	if (s->listener->bind_conf->level < ACCESS_LVL_ADMIN) {
-		si->applet.ctx.cli.msg = stats_permission_denied_msg;
-		si->applet.st0 = STAT_CLI_PRINT;
+		si->appctx.ctx.cli.msg = stats_permission_denied_msg;
+		si->appctx.st0 = STAT_CLI_PRINT;
 		return NULL;
 	}
 
 	if (!*arg) {
-		si->applet.ctx.cli.msg = "A frontend name is expected.\n";
-		si->applet.st0 = STAT_CLI_PRINT;
+		si->appctx.ctx.cli.msg = "A frontend name is expected.\n";
+		si->appctx.st0 = STAT_CLI_PRINT;
 		return NULL;
 	}
 
 	px = findproxy(arg, PR_CAP_FE);
 	if (!px) {
-		si->applet.ctx.cli.msg = "No such frontend.\n";
-		si->applet.st0 = STAT_CLI_PRINT;
+		si->appctx.ctx.cli.msg = "No such frontend.\n";
+		si->appctx.st0 = STAT_CLI_PRINT;
 		return NULL;
 	}
 	return px;
@@ -877,8 +877,8 @@ static struct server *expect_server_admin(struct session *s, struct stream_inter
 	char *line;
 
 	if (s->listener->bind_conf->level < ACCESS_LVL_ADMIN) {
-		si->applet.ctx.cli.msg = stats_permission_denied_msg;
-		si->applet.st0 = STAT_CLI_PRINT;
+		si->appctx.ctx.cli.msg = stats_permission_denied_msg;
+		si->appctx.st0 = STAT_CLI_PRINT;
 		return NULL;
 	}
 
@@ -890,20 +890,20 @@ static struct server *expect_server_admin(struct session *s, struct stream_inter
 		}
 
 	if (!*line || !*arg) {
-		si->applet.ctx.cli.msg = "Require 'backend/server'.\n";
-		si->applet.st0 = STAT_CLI_PRINT;
+		si->appctx.ctx.cli.msg = "Require 'backend/server'.\n";
+		si->appctx.st0 = STAT_CLI_PRINT;
 		return NULL;
 	}
 
 	if (!get_backend_server(arg, line, &px, &sv)) {
-		si->applet.ctx.cli.msg = px ? "No such server.\n" : "No such backend.\n";
-		si->applet.st0 = STAT_CLI_PRINT;
+		si->appctx.ctx.cli.msg = px ? "No such server.\n" : "No such backend.\n";
+		si->appctx.st0 = STAT_CLI_PRINT;
 		return NULL;
 	}
 
 	if (px->state == PR_STSTOPPED) {
-		si->applet.ctx.cli.msg = "Proxy is disabled.\n";
-		si->applet.st0 = STAT_CLI_PRINT;
+		si->appctx.ctx.cli.msg = "Proxy is disabled.\n";
+		si->appctx.st0 = STAT_CLI_PRINT;
 		return NULL;
 	}
 
@@ -912,7 +912,7 @@ static struct server *expect_server_admin(struct session *s, struct stream_inter
 
 /* Processes the stats interpreter on the statistics socket. This function is
  * called from an applet running in a stream interface. The function returns 1
- * if the request was understood, otherwise zero. It sets si->applet.st0 to a value
+ * if the request was understood, otherwise zero. It sets si->appctx.st0 to a value
  * designating the function which will have to process the request, which can
  * also be the print function to display the return message set into cli.msg.
  */
@@ -945,53 +945,53 @@ static int stats_sock_parse_request(struct stream_interface *si, char *line)
 	while (++arg <= MAX_STATS_ARGS)
 		args[arg] = line;
 
-	si->applet.ctx.stats.flags = 0;
+	si->appctx.ctx.stats.flags = 0;
 	if (strcmp(args[0], "show") == 0) {
 		if (strcmp(args[1], "stat") == 0) {
 			if (*args[2] && *args[3] && *args[4]) {
-				si->applet.ctx.stats.flags |= STAT_BOUND;
-				si->applet.ctx.stats.iid = atoi(args[2]);
-				si->applet.ctx.stats.type = atoi(args[3]);
-				si->applet.ctx.stats.sid = atoi(args[4]);
+				si->appctx.ctx.stats.flags |= STAT_BOUND;
+				si->appctx.ctx.stats.iid = atoi(args[2]);
+				si->appctx.ctx.stats.type = atoi(args[3]);
+				si->appctx.ctx.stats.sid = atoi(args[4]);
 			}
 
-			si->applet.st2 = STAT_ST_INIT;
-			si->applet.st0 = STAT_CLI_O_STAT; // stats_dump_stat_to_buffer
+			si->appctx.st2 = STAT_ST_INIT;
+			si->appctx.st0 = STAT_CLI_O_STAT; // stats_dump_stat_to_buffer
 		}
 		else if (strcmp(args[1], "info") == 0) {
-			si->applet.st2 = STAT_ST_INIT;
-			si->applet.st0 = STAT_CLI_O_INFO; // stats_dump_info_to_buffer
+			si->appctx.st2 = STAT_ST_INIT;
+			si->appctx.st0 = STAT_CLI_O_INFO; // stats_dump_info_to_buffer
 		}
 		else if (strcmp(args[1], "sess") == 0) {
-			si->applet.st2 = STAT_ST_INIT;
+			si->appctx.st2 = STAT_ST_INIT;
 			if (s->listener->bind_conf->level < ACCESS_LVL_OPER) {
-				si->applet.ctx.cli.msg = stats_permission_denied_msg;
-				si->applet.st0 = STAT_CLI_PRINT;
+				si->appctx.ctx.cli.msg = stats_permission_denied_msg;
+				si->appctx.st0 = STAT_CLI_PRINT;
 				return 1;
 			}
 			if (*args[2] && strcmp(args[2], "all") == 0)
-				si->applet.ctx.sess.target = (void *)-1;
+				si->appctx.ctx.sess.target = (void *)-1;
 			else if (*args[2])
-				si->applet.ctx.sess.target = (void *)strtoul(args[2], NULL, 0);
+				si->appctx.ctx.sess.target = (void *)strtoul(args[2], NULL, 0);
 			else
-				si->applet.ctx.sess.target = NULL;
-			si->applet.ctx.sess.section = 0; /* start with session status */
-			si->applet.ctx.sess.pos = 0;
-			si->applet.st0 = STAT_CLI_O_SESS; // stats_dump_sess_to_buffer
+				si->appctx.ctx.sess.target = NULL;
+			si->appctx.ctx.sess.section = 0; /* start with session status */
+			si->appctx.ctx.sess.pos = 0;
+			si->appctx.st0 = STAT_CLI_O_SESS; // stats_dump_sess_to_buffer
 		}
 		else if (strcmp(args[1], "errors") == 0) {
 			if (s->listener->bind_conf->level < ACCESS_LVL_OPER) {
-				si->applet.ctx.cli.msg = stats_permission_denied_msg;
-				si->applet.st0 = STAT_CLI_PRINT;
+				si->appctx.ctx.cli.msg = stats_permission_denied_msg;
+				si->appctx.st0 = STAT_CLI_PRINT;
 				return 1;
 			}
 			if (*args[2])
-				si->applet.ctx.errors.iid	= atoi(args[2]);
+				si->appctx.ctx.errors.iid	= atoi(args[2]);
 			else
-				si->applet.ctx.errors.iid	= -1;
-			si->applet.ctx.errors.px = NULL;
-			si->applet.st2 = STAT_ST_INIT;
-			si->applet.st0 = STAT_CLI_O_ERR; // stats_dump_errors_to_buffer
+				si->appctx.ctx.errors.iid	= -1;
+			si->appctx.ctx.errors.px = NULL;
+			si->appctx.st2 = STAT_ST_INIT;
+			si->appctx.st0 = STAT_CLI_O_ERR; // stats_dump_errors_to_buffer
 		}
 		else if (strcmp(args[1], "table") == 0) {
 			stats_sock_table_request(si, args, STAT_CLI_O_TAB);
@@ -1013,8 +1013,8 @@ static int stats_sock_parse_request(struct stream_interface *si, char *line)
 			/* check permissions */
 			if (s->listener->bind_conf->level < ACCESS_LVL_OPER ||
 			    (clrall && s->listener->bind_conf->level < ACCESS_LVL_ADMIN)) {
-				si->applet.ctx.cli.msg = stats_permission_denied_msg;
-				si->applet.st0 = STAT_CLI_PRINT;
+				si->appctx.ctx.cli.msg = stats_permission_denied_msg;
+				si->appctx.st0 = STAT_CLI_PRINT;
 				return 1;
 			}
 
@@ -1081,14 +1081,14 @@ static int stats_sock_parse_request(struct stream_interface *si, char *line)
 				}
 
 			if (!*line) {
-				si->applet.ctx.cli.msg = "Require 'backend/server'.\n";
-				si->applet.st0 = STAT_CLI_PRINT;
+				si->appctx.ctx.cli.msg = "Require 'backend/server'.\n";
+				si->appctx.st0 = STAT_CLI_PRINT;
 				return 1;
 			}
 
 			if (!get_backend_server(args[2], line, &px, &sv)) {
-				si->applet.ctx.cli.msg = px ? "No such server.\n" : "No such backend.\n";
-				si->applet.st0 = STAT_CLI_PRINT;
+				si->appctx.ctx.cli.msg = px ? "No such server.\n" : "No such backend.\n";
+				si->appctx.st0 = STAT_CLI_PRINT;
 				return 1;
 			}
 
@@ -1118,8 +1118,8 @@ static int stats_sock_parse_request(struct stream_interface *si, char *line)
 			 */
 			set_server_drain_state(sv);
 			if (warning) {
-				si->applet.ctx.cli.msg = warning;
-				si->applet.st0 = STAT_CLI_PRINT;
+				si->appctx.ctx.cli.msg = warning;
+				si->appctx.st0 = STAT_CLI_PRINT;
 			}
 			return 1;
 		}
@@ -1129,15 +1129,15 @@ static int stats_sock_parse_request(struct stream_interface *si, char *line)
 				const char *res;
 
 				if (!*args[3]) {
-					si->applet.ctx.cli.msg = "Expects an integer value.\n";
-					si->applet.st0 = STAT_CLI_PRINT;
+					si->appctx.ctx.cli.msg = "Expects an integer value.\n";
+					si->appctx.st0 = STAT_CLI_PRINT;
 					return 1;
 				}
 
 				res = parse_time_err(args[3], &timeout, TIME_UNIT_S);
 				if (res || timeout < 1) {
-					si->applet.ctx.cli.msg = "Invalid timeout value.\n";
-					si->applet.st0 = STAT_CLI_PRINT;
+					si->appctx.ctx.cli.msg = "Invalid timeout value.\n";
+					si->appctx.st0 = STAT_CLI_PRINT;
 					return 1;
 				}
 
@@ -1145,8 +1145,8 @@ static int stats_sock_parse_request(struct stream_interface *si, char *line)
 				return 1;
 			}
 			else {
-				si->applet.ctx.cli.msg = "'set timeout' only supports 'cli'.\n";
-				si->applet.st0 = STAT_CLI_PRINT;
+				si->appctx.ctx.cli.msg = "'set timeout' only supports 'cli'.\n";
+				si->appctx.st0 = STAT_CLI_PRINT;
 				return 1;
 			}
 		}
@@ -1161,15 +1161,15 @@ static int stats_sock_parse_request(struct stream_interface *si, char *line)
 					return 1;
 
 				if (!*args[4]) {
-					si->applet.ctx.cli.msg = "Integer value expected.\n";
-					si->applet.st0 = STAT_CLI_PRINT;
+					si->appctx.ctx.cli.msg = "Integer value expected.\n";
+					si->appctx.st0 = STAT_CLI_PRINT;
 					return 1;
 				}
 
 				v = atoi(args[4]);
 				if (v < 0) {
-					si->applet.ctx.cli.msg = "Value out of range.\n";
-					si->applet.st0 = STAT_CLI_PRINT;
+					si->appctx.ctx.cli.msg = "Value out of range.\n";
+					si->appctx.st0 = STAT_CLI_PRINT;
 					return 1;
 				}
 
@@ -1192,21 +1192,21 @@ static int stats_sock_parse_request(struct stream_interface *si, char *line)
 				int v;
 
 				if (s->listener->bind_conf->level < ACCESS_LVL_ADMIN) {
-					si->applet.ctx.cli.msg = stats_permission_denied_msg;
-					si->applet.st0 = STAT_CLI_PRINT;
+					si->appctx.ctx.cli.msg = stats_permission_denied_msg;
+					si->appctx.st0 = STAT_CLI_PRINT;
 					return 1;
 				}
 
 				if (!*args[3]) {
-					si->applet.ctx.cli.msg = "Expects an integer value.\n";
-					si->applet.st0 = STAT_CLI_PRINT;
+					si->appctx.ctx.cli.msg = "Expects an integer value.\n";
+					si->appctx.st0 = STAT_CLI_PRINT;
 					return 1;
 				}
 
 				v = atoi(args[3]);
 				if (v > global.hardmaxconn) {
-					si->applet.ctx.cli.msg = "Value out of range.\n";
-					si->applet.st0 = STAT_CLI_PRINT;
+					si->appctx.ctx.cli.msg = "Value out of range.\n";
+					si->appctx.st0 = STAT_CLI_PRINT;
 					return 1;
 				}
 
@@ -1223,8 +1223,8 @@ static int stats_sock_parse_request(struct stream_interface *si, char *line)
 				return 1;
 			}
 			else {
-				si->applet.ctx.cli.msg = "'set maxconn' only supports 'frontend' and 'global'.\n";
-				si->applet.st0 = STAT_CLI_PRINT;
+				si->appctx.ctx.cli.msg = "'set maxconn' only supports 'frontend' and 'global'.\n";
+				si->appctx.st0 = STAT_CLI_PRINT;
 				return 1;
 			}
 		}
@@ -1234,21 +1234,21 @@ static int stats_sock_parse_request(struct stream_interface *si, char *line)
 					int v;
 
 					if (s->listener->bind_conf->level < ACCESS_LVL_ADMIN) {
-						si->applet.ctx.cli.msg = stats_permission_denied_msg;
-						si->applet.st0 = STAT_CLI_PRINT;
+						si->appctx.ctx.cli.msg = stats_permission_denied_msg;
+						si->appctx.st0 = STAT_CLI_PRINT;
 						return 1;
 					}
 
 					if (!*args[4]) {
-						si->applet.ctx.cli.msg = "Expects an integer value.\n";
-						si->applet.st0 = STAT_CLI_PRINT;
+						si->appctx.ctx.cli.msg = "Expects an integer value.\n";
+						si->appctx.st0 = STAT_CLI_PRINT;
 						return 1;
 					}
 
 					v = atoi(args[4]);
 					if (v < 0) {
-						si->applet.ctx.cli.msg = "Value out of range.\n";
-						si->applet.st0 = STAT_CLI_PRINT;
+						si->appctx.ctx.cli.msg = "Value out of range.\n";
+						si->appctx.st0 = STAT_CLI_PRINT;
 						return 1;
 					}
 
@@ -1261,8 +1261,8 @@ static int stats_sock_parse_request(struct stream_interface *si, char *line)
 					return 1;
 				}
 				else {
-					si->applet.ctx.cli.msg = "'set rate-limit connections' only supports 'global'.\n";
-					si->applet.st0 = STAT_CLI_PRINT;
+					si->appctx.ctx.cli.msg = "'set rate-limit connections' only supports 'global'.\n";
+					si->appctx.st0 = STAT_CLI_PRINT;
 					return 1;
 				}
 			}
@@ -1271,8 +1271,8 @@ static int stats_sock_parse_request(struct stream_interface *si, char *line)
 					int v;
 
 					if (!*args[4]) {
-						si->applet.ctx.cli.msg = "Expects a maximum input byte rate in kB/s.\n";
-						si->applet.st0 = STAT_CLI_PRINT;
+						si->appctx.ctx.cli.msg = "Expects a maximum input byte rate in kB/s.\n";
+						si->appctx.st0 = STAT_CLI_PRINT;
 						return 1;
 					}
 
@@ -1280,14 +1280,14 @@ static int stats_sock_parse_request(struct stream_interface *si, char *line)
 					global.comp_rate_lim = v * 1024; /* Kilo to bytes. */
 				}
 				else {
-					si->applet.ctx.cli.msg = "'set rate-limit http-compression' only supports 'global'.\n";
-					si->applet.st0 = STAT_CLI_PRINT;
+					si->appctx.ctx.cli.msg = "'set rate-limit http-compression' only supports 'global'.\n";
+					si->appctx.st0 = STAT_CLI_PRINT;
 					return 1;
 				}
 			}
 			else {
-				si->applet.ctx.cli.msg = "'set rate-limit' supports 'connections' and 'http-compression'.\n";
-				si->applet.st0 = STAT_CLI_PRINT;
+				si->appctx.ctx.cli.msg = "'set rate-limit' supports 'connections' and 'http-compression'.\n";
+				si->appctx.st0 = STAT_CLI_PRINT;
 				return 1;
 			}
 		}
@@ -1346,27 +1346,27 @@ static int stats_sock_parse_request(struct stream_interface *si, char *line)
 				return 1;
 
 			if (px->state == PR_STSTOPPED) {
-				si->applet.ctx.cli.msg = "Frontend was previously shut down, cannot enable.\n";
-				si->applet.st0 = STAT_CLI_PRINT;
+				si->appctx.ctx.cli.msg = "Frontend was previously shut down, cannot enable.\n";
+				si->appctx.st0 = STAT_CLI_PRINT;
 				return 1;
 			}
 
 			if (px->state != PR_STPAUSED) {
-				si->applet.ctx.cli.msg = "Frontend is already enabled.\n";
-				si->applet.st0 = STAT_CLI_PRINT;
+				si->appctx.ctx.cli.msg = "Frontend is already enabled.\n";
+				si->appctx.st0 = STAT_CLI_PRINT;
 				return 1;
 			}
 
 			if (!resume_proxy(px)) {
-				si->applet.ctx.cli.msg = "Failed to resume frontend, check logs for precise cause (port conflict?).\n";
-				si->applet.st0 = STAT_CLI_PRINT;
+				si->appctx.ctx.cli.msg = "Failed to resume frontend, check logs for precise cause (port conflict?).\n";
+				si->appctx.st0 = STAT_CLI_PRINT;
 				return 1;
 			}
 			return 1;
 		}
 		else { /* unknown "enable" parameter */
-			si->applet.ctx.cli.msg = "'enable' only supports 'frontend' and 'server'.\n";
-			si->applet.st0 = STAT_CLI_PRINT;
+			si->appctx.ctx.cli.msg = "'enable' only supports 'frontend' and 'server'.\n";
+			si->appctx.st0 = STAT_CLI_PRINT;
 			return 1;
 		}
 	}
@@ -1405,27 +1405,27 @@ static int stats_sock_parse_request(struct stream_interface *si, char *line)
 				return 1;
 
 			if (px->state == PR_STSTOPPED) {
-				si->applet.ctx.cli.msg = "Frontend was previously shut down, cannot disable.\n";
-				si->applet.st0 = STAT_CLI_PRINT;
+				si->appctx.ctx.cli.msg = "Frontend was previously shut down, cannot disable.\n";
+				si->appctx.st0 = STAT_CLI_PRINT;
 				return 1;
 			}
 
 			if (px->state == PR_STPAUSED) {
-				si->applet.ctx.cli.msg = "Frontend is already disabled.\n";
-				si->applet.st0 = STAT_CLI_PRINT;
+				si->appctx.ctx.cli.msg = "Frontend is already disabled.\n";
+				si->appctx.st0 = STAT_CLI_PRINT;
 				return 1;
 			}
 
 			if (!pause_proxy(px)) {
-				si->applet.ctx.cli.msg = "Failed to pause frontend, check logs for precise cause.\n";
-				si->applet.st0 = STAT_CLI_PRINT;
+				si->appctx.ctx.cli.msg = "Failed to pause frontend, check logs for precise cause.\n";
+				si->appctx.st0 = STAT_CLI_PRINT;
 				return 1;
 			}
 			return 1;
 		}
 		else { /* unknown "disable" parameter */
-			si->applet.ctx.cli.msg = "'disable' only supports 'frontend' and 'server'.\n";
-			si->applet.st0 = STAT_CLI_PRINT;
+			si->appctx.ctx.cli.msg = "'disable' only supports 'frontend' and 'server'.\n";
+			si->appctx.st0 = STAT_CLI_PRINT;
 			return 1;
 		}
 	}
@@ -1438,8 +1438,8 @@ static int stats_sock_parse_request(struct stream_interface *si, char *line)
 				return 1;
 
 			if (px->state == PR_STSTOPPED) {
-				si->applet.ctx.cli.msg = "Frontend was already shut down.\n";
-				si->applet.st0 = STAT_CLI_PRINT;
+				si->appctx.ctx.cli.msg = "Frontend was already shut down.\n";
+				si->appctx.st0 = STAT_CLI_PRINT;
 				return 1;
 			}
 
@@ -1454,14 +1454,14 @@ static int stats_sock_parse_request(struct stream_interface *si, char *line)
 			struct session *sess, *ptr;
 
 			if (s->listener->bind_conf->level < ACCESS_LVL_ADMIN) {
-				si->applet.ctx.cli.msg = stats_permission_denied_msg;
-				si->applet.st0 = STAT_CLI_PRINT;
+				si->appctx.ctx.cli.msg = stats_permission_denied_msg;
+				si->appctx.st0 = STAT_CLI_PRINT;
 				return 1;
 			}
 
 			if (!*args[2]) {
-				si->applet.ctx.cli.msg = "Session pointer expected (use 'show sess').\n";
-				si->applet.st0 = STAT_CLI_PRINT;
+				si->appctx.ctx.cli.msg = "Session pointer expected (use 'show sess').\n";
+				si->appctx.st0 = STAT_CLI_PRINT;
 				return 1;
 			}
 
@@ -1475,8 +1475,8 @@ static int stats_sock_parse_request(struct stream_interface *si, char *line)
 
 			/* do we have the session ? */
 			if (sess != ptr) {
-				si->applet.ctx.cli.msg = "No such session (use 'show sess').\n";
-				si->applet.st0 = STAT_CLI_PRINT;
+				si->appctx.ctx.cli.msg = "No such session (use 'show sess').\n";
+				si->appctx.st0 = STAT_CLI_PRINT;
 				return 1;
 			}
 
@@ -1500,14 +1500,14 @@ static int stats_sock_parse_request(struct stream_interface *si, char *line)
 				return 1;
 			}
 			else {
-				si->applet.ctx.cli.msg = "'shutdown sessions' only supports 'server'.\n";
-				si->applet.st0 = STAT_CLI_PRINT;
+				si->appctx.ctx.cli.msg = "'shutdown sessions' only supports 'server'.\n";
+				si->appctx.st0 = STAT_CLI_PRINT;
 				return 1;
 			}
 		}
 		else { /* unknown "disable" parameter */
-			si->applet.ctx.cli.msg = "'shutdown' only supports 'frontend', 'session' and 'sessions'.\n";
-			si->applet.st0 = STAT_CLI_PRINT;
+			si->appctx.ctx.cli.msg = "'shutdown' only supports 'frontend', 'session' and 'sessions'.\n";
+			si->appctx.st0 = STAT_CLI_PRINT;
 			return 1;
 		}
 	}
@@ -1521,8 +1521,8 @@ static int stats_sock_parse_request(struct stream_interface *si, char *line)
  * used to processes I/O from/to the stats unix socket. The system relies on a
  * state machine handling requests and various responses. We read a request,
  * then we process it and send the response, and we possibly display a prompt.
- * Then we can read again. The state is stored in si->applet.st0 and is one of the
- * STAT_CLI_* constants. si->applet.st1 is used to indicate whether prompt is enabled
+ * Then we can read again. The state is stored in si->appctx.st0 and is one of the
+ * STAT_CLI_* constants. si->appctx.st1 is used to indicate whether prompt is enabled
  * or not.
  */
 static void cli_io_handler(struct stream_interface *si)
@@ -1536,19 +1536,19 @@ static void cli_io_handler(struct stream_interface *si)
 		goto out;
 
 	while (1) {
-		if (si->applet.st0 == STAT_CLI_INIT) {
+		if (si->appctx.st0 == STAT_CLI_INIT) {
 			/* Stats output not initialized yet */
-			memset(&si->applet.ctx.stats, 0, sizeof(si->applet.ctx.stats));
-			si->applet.st0 = STAT_CLI_GETREQ;
+			memset(&si->appctx.ctx.stats, 0, sizeof(si->appctx.ctx.stats));
+			si->appctx.st0 = STAT_CLI_GETREQ;
 		}
-		else if (si->applet.st0 == STAT_CLI_END) {
+		else if (si->appctx.st0 == STAT_CLI_END) {
 			/* Let's close for real now. We just close the request
 			 * side, the conditions below will complete if needed.
 			 */
 			si_shutw(si);
 			break;
 		}
-		else if (si->applet.st0 == STAT_CLI_GETREQ) {
+		else if (si->appctx.st0 == STAT_CLI_GETREQ) {
 			/* ensure we have some output room left in the event we
 			 * would want to return some info right after parsing.
 			 */
@@ -1559,7 +1559,7 @@ static void cli_io_handler(struct stream_interface *si)
 			if (reql <= 0) { /* closed or EOL not found */
 				if (reql == 0)
 					break;
-				si->applet.st0 = STAT_CLI_END;
+				si->appctx.st0 = STAT_CLI_END;
 				continue;
 			}
 
@@ -1579,7 +1579,7 @@ static void cli_io_handler(struct stream_interface *si)
 			 */
 			len = reql - 1;
 			if (trash.str[len] != '\n') {
-				si->applet.st0 = STAT_CLI_END;
+				si->appctx.st0 = STAT_CLI_END;
 				continue;
 			}
 
@@ -1588,30 +1588,30 @@ static void cli_io_handler(struct stream_interface *si)
 
 			trash.str[len] = '\0';
 
-			si->applet.st0 = STAT_CLI_PROMPT;
+			si->appctx.st0 = STAT_CLI_PROMPT;
 			if (len) {
 				if (strcmp(trash.str, "quit") == 0) {
-					si->applet.st0 = STAT_CLI_END;
+					si->appctx.st0 = STAT_CLI_END;
 					continue;
 				}
 				else if (strcmp(trash.str, "prompt") == 0)
-					si->applet.st1 = !si->applet.st1;
+					si->appctx.st1 = !si->appctx.st1;
 				else if (strcmp(trash.str, "help") == 0 ||
 					 !stats_sock_parse_request(si, trash.str)) {
-					si->applet.ctx.cli.msg = stats_sock_usage_msg;
-					si->applet.st0 = STAT_CLI_PRINT;
+					si->appctx.ctx.cli.msg = stats_sock_usage_msg;
+					si->appctx.st0 = STAT_CLI_PRINT;
 				}
 				/* NB: stats_sock_parse_request() may have put
-				 * another STAT_CLI_O_* into si->applet.st0.
+				 * another STAT_CLI_O_* into si->appctx.st0.
 				 */
 			}
-			else if (!si->applet.st1) {
+			else if (!si->appctx.st1) {
 				/* if prompt is disabled, print help on empty lines,
 				 * so that the user at least knows how to enable
 				 * prompt and find help.
 				 */
-				si->applet.ctx.cli.msg = stats_sock_usage_msg;
-				si->applet.st0 = STAT_CLI_PRINT;
+				si->appctx.ctx.cli.msg = stats_sock_usage_msg;
+				si->appctx.st0 = STAT_CLI_PRINT;
 			}
 
 			/* re-adjust req buffer */
@@ -1620,49 +1620,49 @@ static void cli_io_handler(struct stream_interface *si)
 		}
 		else {	/* output functions: first check if the output buffer is closed then abort */
 			if (res->flags & (CF_SHUTR_NOW|CF_SHUTR)) {
-				si->applet.st0 = STAT_CLI_END;
+				si->appctx.st0 = STAT_CLI_END;
 				continue;
 			}
 
-			switch (si->applet.st0) {
+			switch (si->appctx.st0) {
 			case STAT_CLI_PRINT:
-				if (bi_putstr(si->ib, si->applet.ctx.cli.msg) != -1)
-					si->applet.st0 = STAT_CLI_PROMPT;
+				if (bi_putstr(si->ib, si->appctx.ctx.cli.msg) != -1)
+					si->appctx.st0 = STAT_CLI_PROMPT;
 				break;
 			case STAT_CLI_O_INFO:
 				if (stats_dump_info_to_buffer(si))
-					si->applet.st0 = STAT_CLI_PROMPT;
+					si->appctx.st0 = STAT_CLI_PROMPT;
 				break;
 			case STAT_CLI_O_STAT:
 				if (stats_dump_stat_to_buffer(si, NULL))
-					si->applet.st0 = STAT_CLI_PROMPT;
+					si->appctx.st0 = STAT_CLI_PROMPT;
 				break;
 			case STAT_CLI_O_SESS:
 				if (stats_dump_sess_to_buffer(si))
-					si->applet.st0 = STAT_CLI_PROMPT;
+					si->appctx.st0 = STAT_CLI_PROMPT;
 				break;
 			case STAT_CLI_O_ERR:	/* errors dump */
 				if (stats_dump_errors_to_buffer(si))
-					si->applet.st0 = STAT_CLI_PROMPT;
+					si->appctx.st0 = STAT_CLI_PROMPT;
 				break;
 			case STAT_CLI_O_TAB:
 			case STAT_CLI_O_CLR:
-				if (stats_table_request(si, si->applet.st0))
-					si->applet.st0 = STAT_CLI_PROMPT;
+				if (stats_table_request(si, si->appctx.st0))
+					si->appctx.st0 = STAT_CLI_PROMPT;
 				break;
 			default: /* abnormal state */
-				si->applet.st0 = STAT_CLI_PROMPT;
+				si->appctx.st0 = STAT_CLI_PROMPT;
 				break;
 			}
 
 			/* The post-command prompt is either LF alone or LF + '> ' in interactive mode */
-			if (si->applet.st0 == STAT_CLI_PROMPT) {
-				if (bi_putstr(si->ib, si->applet.st1 ? "\n> " : "\n") != -1)
-					si->applet.st0 = STAT_CLI_GETREQ;
+			if (si->appctx.st0 == STAT_CLI_PROMPT) {
+				if (bi_putstr(si->ib, si->appctx.st1 ? "\n> " : "\n") != -1)
+					si->appctx.st0 = STAT_CLI_GETREQ;
 			}
 
 			/* If the output functions are still there, it means they require more room. */
-			if (si->applet.st0 >= STAT_CLI_OUTPUT)
+			if (si->appctx.st0 >= STAT_CLI_OUTPUT)
 				break;
 
 			/* Now we close the output if one of the writers did so,
@@ -1670,17 +1670,17 @@ static void cli_io_handler(struct stream_interface *si)
 			 * buffer is empty. This still allows pipelined requests
 			 * to be sent in non-interactive mode.
 			 */
-			if ((res->flags & (CF_SHUTW|CF_SHUTW_NOW)) || (!si->applet.st1 && !req->buf->o)) {
-				si->applet.st0 = STAT_CLI_END;
+			if ((res->flags & (CF_SHUTW|CF_SHUTW_NOW)) || (!si->appctx.st1 && !req->buf->o)) {
+				si->appctx.st0 = STAT_CLI_END;
 				continue;
 			}
 
 			/* switch state back to GETREQ to read next requests */
-			si->applet.st0 = STAT_CLI_GETREQ;
+			si->appctx.st0 = STAT_CLI_GETREQ;
 		}
 	}
 
-	if ((res->flags & CF_SHUTR) && (si->state == SI_ST_EST) && (si->applet.st0 != STAT_CLI_GETREQ)) {
+	if ((res->flags & CF_SHUTR) && (si->state == SI_ST_EST) && (si->appctx.st0 != STAT_CLI_GETREQ)) {
 		DPRINTF(stderr, "%s@%d: si to buf closed. req=%08x, res=%08x, st=%d\n",
 			__FUNCTION__, __LINE__, req->flags, res->flags, si->state);
 		/* Other side has closed, let's abort if we have no more processing to do
@@ -1691,7 +1691,7 @@ static void cli_io_handler(struct stream_interface *si)
 		si_shutw(si);
 	}
 
-	if ((req->flags & CF_SHUTW) && (si->state == SI_ST_EST) && (si->applet.st0 < STAT_CLI_OUTPUT)) {
+	if ((req->flags & CF_SHUTW) && (si->state == SI_ST_EST) && (si->appctx.st0 < STAT_CLI_OUTPUT)) {
 		DPRINTF(stderr, "%s@%d: buf to si closed. req=%08x, res=%08x, st=%d\n",
 			__FUNCTION__, __LINE__, req->flags, res->flags, si->state);
 		/* We have no more processing to do, and nothing more to send, and
@@ -1798,15 +1798,15 @@ static int stats_dump_fe_stats(struct stream_interface *si, struct proxy *px)
 	if (!(px->cap & PR_CAP_FE))
 		return 0;
 
-	if ((si->applet.ctx.stats.flags & STAT_BOUND) && !(si->applet.ctx.stats.type & (1 << STATS_TYPE_FE)))
+	if ((si->appctx.ctx.stats.flags & STAT_BOUND) && !(si->appctx.ctx.stats.type & (1 << STATS_TYPE_FE)))
 		return 0;
 
-	if (si->applet.ctx.stats.flags & STAT_FMT_HTML) {
+	if (si->appctx.ctx.stats.flags & STAT_FMT_HTML) {
 		chunk_appendf(&trash,
 		              /* name, queue */
 		              "<tr class=\"frontend\">");
 
-		if (px->cap & PR_CAP_BE && px->srv && (si->applet.ctx.stats.flags & STAT_ADMIN)) {
+		if (px->cap & PR_CAP_BE && px->srv && (si->appctx.ctx.stats.flags & STAT_ADMIN)) {
 			/* Column sub-heading for Enable or Disable server */
 			chunk_appendf(&trash, "<td></td>");
 		}
@@ -2006,9 +2006,9 @@ static int stats_dump_fe_stats(struct stream_interface *si, struct proxy *px)
  */
 static int stats_dump_li_stats(struct stream_interface *si, struct proxy *px, struct listener *l, int flags)
 {
-	if (si->applet.ctx.stats.flags & STAT_FMT_HTML) {
+	if (si->appctx.ctx.stats.flags & STAT_FMT_HTML) {
 		chunk_appendf(&trash, "<tr class=socket>");
-		if (px->cap & PR_CAP_BE && px->srv && (si->applet.ctx.stats.flags & STAT_ADMIN)) {
+		if (px->cap & PR_CAP_BE && px->srv && (si->appctx.ctx.stats.flags & STAT_ADMIN)) {
 			/* Column sub-heading for Enable or Disable server */
 			chunk_appendf(&trash, "<td></td>");
 		}
@@ -2139,7 +2139,7 @@ static int stats_dump_sv_stats(struct stream_interface *si, struct proxy *px, in
 	struct chunk src;
 	int i;
 
-	if (si->applet.ctx.stats.flags & STAT_FMT_HTML) {
+	if (si->appctx.ctx.stats.flags & STAT_FMT_HTML) {
 		static char *srv_hlt_st[9] = {
 			"DOWN",
 			"DN %d/%d &uarr;",
@@ -2159,7 +2159,7 @@ static int stats_dump_sv_stats(struct stream_interface *si, struct proxy *px, in
 			              "<tr class=\"%s%d\">",
 			              (sv->state & SRV_BACKUP) ? "backup" : "active", state);
 
-		if ((px->cap & PR_CAP_BE) && px->srv && (si->applet.ctx.stats.flags & STAT_ADMIN))
+		if ((px->cap & PR_CAP_BE) && px->srv && (si->appctx.ctx.stats.flags & STAT_ADMIN))
 			chunk_appendf(&trash,
 			              "<td><input type=\"checkbox\" name=\"s\" value=\"%s\"></td>",
 			              sv->id);
@@ -2520,12 +2520,12 @@ static int stats_dump_be_stats(struct stream_interface *si, struct proxy *px, in
 	if (!(px->cap & PR_CAP_BE))
 		return 0;
 
-	if ((si->applet.ctx.stats.flags & STAT_BOUND) && !(si->applet.ctx.stats.type & (1 << STATS_TYPE_BE)))
+	if ((si->appctx.ctx.stats.flags & STAT_BOUND) && !(si->appctx.ctx.stats.type & (1 << STATS_TYPE_BE)))
 		return 0;
 
-	if (si->applet.ctx.stats.flags & STAT_FMT_HTML) {
+	if (si->appctx.ctx.stats.flags & STAT_FMT_HTML) {
 		chunk_appendf(&trash, "<tr class=\"backend\">");
-		if (px->srv && (si->applet.ctx.stats.flags & STAT_ADMIN)) {
+		if (px->srv && (si->appctx.ctx.stats.flags & STAT_ADMIN)) {
 			/* Column sub-heading for Enable or Disable server */
 			chunk_appendf(&trash, "<td></td>");
 		}
@@ -2744,22 +2744,22 @@ static void stats_dump_html_px_hdr(struct stream_interface *si, struct proxy *px
 {
 	char scope_txt[STAT_SCOPE_TXT_MAXLEN + sizeof STAT_SCOPE_PATTERN];
 
-	if (px->cap & PR_CAP_BE && px->srv && (si->applet.ctx.stats.flags & STAT_ADMIN)) {
+	if (px->cap & PR_CAP_BE && px->srv && (si->appctx.ctx.stats.flags & STAT_ADMIN)) {
 		/* A form to enable/disable this proxy servers */
 
-		/* scope_txt = search pattern + search query, si->applet.ctx.stats.scope_len is always <= STAT_SCOPE_TXT_MAXLEN */
+		/* scope_txt = search pattern + search query, si->appctx.ctx.stats.scope_len is always <= STAT_SCOPE_TXT_MAXLEN */
 		scope_txt[0] = 0;
-		if (si->applet.ctx.stats.scope_len) {
+		if (si->appctx.ctx.stats.scope_len) {
 			strcpy(scope_txt, STAT_SCOPE_PATTERN);
-			memcpy(scope_txt + strlen(STAT_SCOPE_PATTERN), bo_ptr(si->ob->buf) + si->applet.ctx.stats.scope_str, si->applet.ctx.stats.scope_len);
-			scope_txt[strlen(STAT_SCOPE_PATTERN) + si->applet.ctx.stats.scope_len] = 0;
+			memcpy(scope_txt + strlen(STAT_SCOPE_PATTERN), bo_ptr(si->ob->buf) + si->appctx.ctx.stats.scope_str, si->appctx.ctx.stats.scope_len);
+			scope_txt[strlen(STAT_SCOPE_PATTERN) + si->appctx.ctx.stats.scope_len] = 0;
 		}
 
 		chunk_appendf(&trash,
 			      "<form action=\"%s%s%s%s\" method=\"post\">",
 			      uri->uri_prefix,
-			      (si->applet.ctx.stats.flags & STAT_HIDE_DOWN) ? ";up" : "",
-			      (si->applet.ctx.stats.flags & STAT_NO_REFRESH) ? ";norefresh" : "",
+			      (si->appctx.ctx.stats.flags & STAT_HIDE_DOWN) ? ";up" : "",
+			      (si->appctx.ctx.stats.flags & STAT_NO_REFRESH) ? ";norefresh" : "",
 			      scope_txt);
 	}
 
@@ -2794,7 +2794,7 @@ static void stats_dump_html_px_hdr(struct stream_interface *si, struct proxy *px
 	              (uri->flags & ST_SHLGNDS) ? "</u>":"",
 	              px->desc ? "desc" : "empty", px->desc ? px->desc : "");
 
-	if ((px->cap & PR_CAP_BE) && px->srv && (si->applet.ctx.stats.flags & STAT_ADMIN)) {
+	if ((px->cap & PR_CAP_BE) && px->srv && (si->appctx.ctx.stats.flags & STAT_ADMIN)) {
 		/* Column heading for Enable or Disable server */
 		chunk_appendf(&trash, "<th rowspan=2 width=1></th>");
 	}
@@ -2826,7 +2826,7 @@ static void stats_dump_html_px_end(struct stream_interface *si, struct proxy *px
 {
 	chunk_appendf(&trash, "</table>");
 
-	if ((px->cap & PR_CAP_BE) && px->srv && (si->applet.ctx.stats.flags & STAT_ADMIN)) {
+	if ((px->cap & PR_CAP_BE) && px->srv && (si->appctx.ctx.stats.flags & STAT_ADMIN)) {
 		/* close the form used to enable/disable this proxy servers */
 		chunk_appendf(&trash,
 			      "Choose the action to perform on the checked servers : "
@@ -2863,7 +2863,7 @@ static int stats_dump_proxy_to_buffer(struct stream_interface *si, struct proxy
 
 	chunk_reset(&trash);
 
-	switch (si->applet.ctx.stats.px_st) {
+	switch (si->appctx.ctx.stats.px_st) {
 	case STAT_PX_ST_INIT:
 		/* we are on a new proxy */
 		if (uri && uri->scope) {
@@ -2893,26 +2893,26 @@ static int stats_dump_proxy_to_buffer(struct stream_interface *si, struct proxy
 		/* if the user has requested a limited output and the proxy
 		 * name does not match, skip it.
 		 */
-		if (si->applet.ctx.stats.scope_len &&
-		    strnistr(px->id, strlen(px->id), bo_ptr(si->ob->buf) + si->applet.ctx.stats.scope_str, si->applet.ctx.stats.scope_len) == NULL)
+		if (si->appctx.ctx.stats.scope_len &&
+		    strnistr(px->id, strlen(px->id), bo_ptr(si->ob->buf) + si->appctx.ctx.stats.scope_str, si->appctx.ctx.stats.scope_len) == NULL)
 			return 1;
 
-		if ((si->applet.ctx.stats.flags & STAT_BOUND) &&
-		    (si->applet.ctx.stats.iid != -1) &&
-		    (px->uuid != si->applet.ctx.stats.iid))
+		if ((si->appctx.ctx.stats.flags & STAT_BOUND) &&
+		    (si->appctx.ctx.stats.iid != -1) &&
+		    (px->uuid != si->appctx.ctx.stats.iid))
 			return 1;
 
-		si->applet.ctx.stats.px_st = STAT_PX_ST_TH;
+		si->appctx.ctx.stats.px_st = STAT_PX_ST_TH;
 		/* fall through */
 
 	case STAT_PX_ST_TH:
-		if (si->applet.ctx.stats.flags & STAT_FMT_HTML) {
+		if (si->appctx.ctx.stats.flags & STAT_FMT_HTML) {
 			stats_dump_html_px_hdr(si, px, uri);
 			if (bi_putchk(rep, &trash) == -1)
 				return 0;
 		}
 
-		si->applet.ctx.stats.px_st = STAT_PX_ST_FE;
+		si->appctx.ctx.stats.px_st = STAT_PX_ST_FE;
 		/* fall through */
 
 	case STAT_PX_ST_FE:
@@ -2921,25 +2921,25 @@ static int stats_dump_proxy_to_buffer(struct stream_interface *si, struct proxy
 			if (bi_putchk(rep, &trash) == -1)
 				return 0;
 
-		si->applet.ctx.stats.l = px->conf.listeners.n;
-		si->applet.ctx.stats.px_st = STAT_PX_ST_LI;
+		si->appctx.ctx.stats.l = px->conf.listeners.n;
+		si->appctx.ctx.stats.px_st = STAT_PX_ST_LI;
 		/* fall through */
 
 	case STAT_PX_ST_LI:
 		/* stats.l has been initialized above */
-		for (; si->applet.ctx.stats.l != &px->conf.listeners; si->applet.ctx.stats.l = l->by_fe.n) {
+		for (; si->appctx.ctx.stats.l != &px->conf.listeners; si->appctx.ctx.stats.l = l->by_fe.n) {
 			if (buffer_almost_full(rep->buf))
 				return 0;
 
-			l = LIST_ELEM(si->applet.ctx.stats.l, struct listener *, by_fe);
+			l = LIST_ELEM(si->appctx.ctx.stats.l, struct listener *, by_fe);
 			if (!l->counters)
 				continue;
 
-			if (si->applet.ctx.stats.flags & STAT_BOUND) {
-				if (!(si->applet.ctx.stats.type & (1 << STATS_TYPE_SO)))
+			if (si->appctx.ctx.stats.flags & STAT_BOUND) {
+				if (!(si->appctx.ctx.stats.type & (1 << STATS_TYPE_SO)))
 					break;
 
-				if (si->applet.ctx.stats.sid != -1 && l->luid != si->applet.ctx.stats.sid)
+				if (si->appctx.ctx.stats.sid != -1 && l->luid != si->appctx.ctx.stats.sid)
 					continue;
 			}
 
@@ -2949,25 +2949,25 @@ static int stats_dump_proxy_to_buffer(struct stream_interface *si, struct proxy
 					return 0;
 		}
 
-		si->applet.ctx.stats.sv = px->srv; /* may be NULL */
-		si->applet.ctx.stats.px_st = STAT_PX_ST_SV;
+		si->appctx.ctx.stats.sv = px->srv; /* may be NULL */
+		si->appctx.ctx.stats.px_st = STAT_PX_ST_SV;
 		/* fall through */
 
 	case STAT_PX_ST_SV:
 		/* stats.sv has been initialized above */
-		for (; si->applet.ctx.stats.sv != NULL; si->applet.ctx.stats.sv = sv->next) {
+		for (; si->appctx.ctx.stats.sv != NULL; si->appctx.ctx.stats.sv = sv->next) {
 			int sv_state; /* 0=DOWN, 1=going up, 2=going down, 3=UP, 4,5=NOLB, 6=unchecked */
 
 			if (buffer_almost_full(rep->buf))
 				return 0;
 
-			sv = si->applet.ctx.stats.sv;
+			sv = si->appctx.ctx.stats.sv;
 
-			if (si->applet.ctx.stats.flags & STAT_BOUND) {
-				if (!(si->applet.ctx.stats.type & (1 << STATS_TYPE_SV)))
+			if (si->appctx.ctx.stats.flags & STAT_BOUND) {
+				if (!(si->appctx.ctx.stats.type & (1 << STATS_TYPE_SV)))
 					break;
 
-				if (si->applet.ctx.stats.sid != -1 && sv->puid != si->applet.ctx.stats.sid)
+				if (si->appctx.ctx.stats.sid != -1 && sv->puid != si->appctx.ctx.stats.sid)
 					continue;
 			}
 
@@ -2996,9 +2996,9 @@ static int stats_dump_proxy_to_buffer(struct stream_interface *si, struct proxy
 				else
 					sv_state = 0; /* DOWN */
 
-			if (((sv_state == 0) || (sv->state & SRV_MAINTAIN)) && (si->applet.ctx.stats.flags & STAT_HIDE_DOWN)) {
+			if (((sv_state == 0) || (sv->state & SRV_MAINTAIN)) && (si->appctx.ctx.stats.flags & STAT_HIDE_DOWN)) {
 				/* do not report servers which are DOWN */
-				si->applet.ctx.stats.sv = sv->next;
+				si->appctx.ctx.stats.sv = sv->next;
 				continue;
 			}
 
@@ -3007,7 +3007,7 @@ static int stats_dump_proxy_to_buffer(struct stream_interface *si, struct proxy
 					return 0;
 		} /* for sv */
 
-		si->applet.ctx.stats.px_st = STAT_PX_ST_BE;
+		si->appctx.ctx.stats.px_st = STAT_PX_ST_BE;
 		/* fall through */
 
 	case STAT_PX_ST_BE:
@@ -3016,17 +3016,17 @@ static int stats_dump_proxy_to_buffer(struct stream_interface *si, struct proxy
 			if (bi_putchk(rep, &trash) == -1)
 				return 0;
 
-		si->applet.ctx.stats.px_st = STAT_PX_ST_END;
+		si->appctx.ctx.stats.px_st = STAT_PX_ST_END;
 		/* fall through */
 
 	case STAT_PX_ST_END:
-		if (si->applet.ctx.stats.flags & STAT_FMT_HTML) {
+		if (si->appctx.ctx.stats.flags & STAT_FMT_HTML) {
 			stats_dump_html_px_end(si, px);
 			if (bi_putchk(rep, &trash) == -1)
 				return 0;
 		}
 
-		si->applet.ctx.stats.px_st = STAT_PX_ST_FIN;
+		si->appctx.ctx.stats.px_st = STAT_PX_ST_FIN;
 		/* fall through */
 
 	case STAT_PX_ST_FIN:
@@ -3225,54 +3225,54 @@ static void stats_dump_html_info(struct stream_interface *si, struct uri_auth *u
 	              run_queue_cur, nb_tasks_cur, idle_pct
 	              );
 
-	/* scope_txt = search query, si->applet.ctx.stats.scope_len is always <= STAT_SCOPE_TXT_MAXLEN */
-	memcpy(scope_txt, bo_ptr(si->ob->buf) + si->applet.ctx.stats.scope_str, si->applet.ctx.stats.scope_len);
-	scope_txt[si->applet.ctx.stats.scope_len] = '\0';
+	/* scope_txt = search query, si->appctx.ctx.stats.scope_len is always <= STAT_SCOPE_TXT_MAXLEN */
+	memcpy(scope_txt, bo_ptr(si->ob->buf) + si->appctx.ctx.stats.scope_str, si->appctx.ctx.stats.scope_len);
+	scope_txt[si->appctx.ctx.stats.scope_len] = '\0';
 
 	chunk_appendf(&trash,
 		      "<li><form method=\"GET\" action=\"%s%s%s\">Scope : <input value=\"%s\" name=\"" STAT_SCOPE_INPUT_NAME "\" size=\"8\" maxlength=\"%d\" tabindex=\"1\"/></form>\n",
 		      uri->uri_prefix,
-		      (si->applet.ctx.stats.flags & STAT_HIDE_DOWN) ? ";up" : "",
-		      (si->applet.ctx.stats.flags & STAT_NO_REFRESH) ? ";norefresh" : "",
-		      (si->applet.ctx.stats.scope_len > 0) ? scope_txt : "",
+		      (si->appctx.ctx.stats.flags & STAT_HIDE_DOWN) ? ";up" : "",
+		      (si->appctx.ctx.stats.flags & STAT_NO_REFRESH) ? ";norefresh" : "",
+		      (si->appctx.ctx.stats.scope_len > 0) ? scope_txt : "",
 		      STAT_SCOPE_TXT_MAXLEN);
 
-	/* scope_txt = search pattern + search query, si->applet.ctx.stats.scope_len is always <= STAT_SCOPE_TXT_MAXLEN */
+	/* scope_txt = search pattern + search query, si->appctx.ctx.stats.scope_len is always <= STAT_SCOPE_TXT_MAXLEN */
 	scope_txt[0] = 0;
-	if (si->applet.ctx.stats.scope_len) {
+	if (si->appctx.ctx.stats.scope_len) {
 		strcpy(scope_txt, STAT_SCOPE_PATTERN);
-		memcpy(scope_txt + strlen(STAT_SCOPE_PATTERN), bo_ptr(si->ob->buf) + si->applet.ctx.stats.scope_str, si->applet.ctx.stats.scope_len);
-		scope_txt[strlen(STAT_SCOPE_PATTERN) + si->applet.ctx.stats.scope_len] = 0;
+		memcpy(scope_txt + strlen(STAT_SCOPE_PATTERN), bo_ptr(si->ob->buf) + si->appctx.ctx.stats.scope_str, si->appctx.ctx.stats.scope_len);
+		scope_txt[strlen(STAT_SCOPE_PATTERN) + si->appctx.ctx.stats.scope_len] = 0;
 	}
 
-	if (si->applet.ctx.stats.flags & STAT_HIDE_DOWN)
+	if (si->appctx.ctx.stats.flags & STAT_HIDE_DOWN)
 		chunk_appendf(&trash,
 		              "<li><a href=\"%s%s%s%s\">Show all servers</a><br>\n",
 		              uri->uri_prefix,
 		              "",
-		              (si->applet.ctx.stats.flags & STAT_NO_REFRESH) ? ";norefresh" : "",
+		              (si->appctx.ctx.stats.flags & STAT_NO_REFRESH) ? ";norefresh" : "",
 			      scope_txt);
 	else
 		chunk_appendf(&trash,
 		              "<li><a href=\"%s%s%s%s\">Hide 'DOWN' servers</a><br>\n",
 		              uri->uri_prefix,
 		              ";up",
-		              (si->applet.ctx.stats.flags & STAT_NO_REFRESH) ? ";norefresh" : "",
+		              (si->appctx.ctx.stats.flags & STAT_NO_REFRESH) ? ";norefresh" : "",
 			      scope_txt);
 
 	if (uri->refresh > 0) {
-		if (si->applet.ctx.stats.flags & STAT_NO_REFRESH)
+		if (si->appctx.ctx.stats.flags & STAT_NO_REFRESH)
 			chunk_appendf(&trash,
 			              "<li><a href=\"%s%s%s%s\">Enable refresh</a><br>\n",
 			              uri->uri_prefix,
-			              (si->applet.ctx.stats.flags & STAT_HIDE_DOWN) ? ";up" : "",
+			              (si->appctx.ctx.stats.flags & STAT_HIDE_DOWN) ? ";up" : "",
 			              "",
 				      scope_txt);
 		else
 			chunk_appendf(&trash,
 			              "<li><a href=\"%s%s%s%s\">Disable refresh</a><br>\n",
 			              uri->uri_prefix,
-			              (si->applet.ctx.stats.flags & STAT_HIDE_DOWN) ? ";up" : "",
+			              (si->appctx.ctx.stats.flags & STAT_HIDE_DOWN) ? ";up" : "",
 			              ";norefresh",
 				      scope_txt);
 	}
@@ -3280,8 +3280,8 @@ static void stats_dump_html_info(struct stream_interface *si, struct uri_auth *u
 	chunk_appendf(&trash,
 	              "<li><a href=\"%s%s%s%s\">Refresh now</a><br>\n",
 	              uri->uri_prefix,
-	              (si->applet.ctx.stats.flags & STAT_HIDE_DOWN) ? ";up" : "",
-	              (si->applet.ctx.stats.flags & STAT_NO_REFRESH) ? ";norefresh" : "",
+	              (si->appctx.ctx.stats.flags & STAT_HIDE_DOWN) ? ";up" : "",
+	              (si->appctx.ctx.stats.flags & STAT_NO_REFRESH) ? ";norefresh" : "",
 		      scope_txt);
 
 	chunk_appendf(&trash,
@@ -3303,16 +3303,16 @@ static void stats_dump_html_info(struct stream_interface *si, struct uri_auth *u
 	              ""
 	              );
 
-	if (si->applet.ctx.stats.st_code) {
-		switch (si->applet.ctx.stats.st_code) {
+	if (si->appctx.ctx.stats.st_code) {
+		switch (si->appctx.ctx.stats.st_code) {
 		case STAT_STATUS_DONE:
 			chunk_appendf(&trash,
 			              "<p><div class=active3>"
 			              "<a class=lfsb href=\"%s%s%s%s\" title=\"Remove this message\">[X]</a> "
 			              "Action processed successfully."
 			              "</div>\n", uri->uri_prefix,
-			              (si->applet.ctx.stats.flags & STAT_HIDE_DOWN) ? ";up" : "",
-			              (si->applet.ctx.stats.flags & STAT_NO_REFRESH) ? ";norefresh" : "",
+			              (si->appctx.ctx.stats.flags & STAT_HIDE_DOWN) ? ";up" : "",
+			              (si->appctx.ctx.stats.flags & STAT_NO_REFRESH) ? ";norefresh" : "",
 			              scope_txt);
 			break;
 		case STAT_STATUS_NONE:
@@ -3321,8 +3321,8 @@ static void stats_dump_html_info(struct stream_interface *si, struct uri_auth *u
 			              "<a class=lfsb href=\"%s%s%s%s\" title=\"Remove this message\">[X]</a> "
 			              "Nothing has changed."
 			              "</div>\n", uri->uri_prefix,
-			              (si->applet.ctx.stats.flags & STAT_HIDE_DOWN) ? ";up" : "",
-			              (si->applet.ctx.stats.flags & STAT_NO_REFRESH) ? ";norefresh" : "",
+			              (si->appctx.ctx.stats.flags & STAT_HIDE_DOWN) ? ";up" : "",
+			              (si->appctx.ctx.stats.flags & STAT_NO_REFRESH) ? ";norefresh" : "",
 			              scope_txt);
 			break;
 		case STAT_STATUS_PART:
@@ -3332,8 +3332,8 @@ static void stats_dump_html_info(struct stream_interface *si, struct uri_auth *u
 			              "Action partially processed.<br>"
 			              "Some server names are probably unknown or ambiguous (duplicated names in the backend)."
 			              "</div>\n", uri->uri_prefix,
-			              (si->applet.ctx.stats.flags & STAT_HIDE_DOWN) ? ";up" : "",
-			              (si->applet.ctx.stats.flags & STAT_NO_REFRESH) ? ";norefresh" : "",
+			              (si->appctx.ctx.stats.flags & STAT_HIDE_DOWN) ? ";up" : "",
+			              (si->appctx.ctx.stats.flags & STAT_NO_REFRESH) ? ";norefresh" : "",
 			              scope_txt);
 			break;
 		case STAT_STATUS_ERRP:
@@ -3347,8 +3347,8 @@ static void stats_dump_html_info(struct stream_interface *si, struct uri_auth *u
 			              "<li>Some server names are probably unknown or ambiguous (duplicated names in the backend).</li>"
 			              "</ul>"
 			              "</div>\n", uri->uri_prefix,
-			              (si->applet.ctx.stats.flags & STAT_HIDE_DOWN) ? ";up" : "",
-			              (si->applet.ctx.stats.flags & STAT_NO_REFRESH) ? ";norefresh" : "",
+			              (si->appctx.ctx.stats.flags & STAT_HIDE_DOWN) ? ";up" : "",
+			              (si->appctx.ctx.stats.flags & STAT_NO_REFRESH) ? ";norefresh" : "",
 			              scope_txt);
 			break;
 		case STAT_STATUS_EXCD:
@@ -3358,8 +3358,8 @@ static void stats_dump_html_info(struct stream_interface *si, struct uri_auth *u
 			              "<b>Action not processed : the buffer couldn't store all the data.<br>"
 			              "You should retry with less servers at a time.</b>"
 			              "</div>\n", uri->uri_prefix,
-			              (si->applet.ctx.stats.flags & STAT_HIDE_DOWN) ? ";up" : "",
-			              (si->applet.ctx.stats.flags & STAT_NO_REFRESH) ? ";norefresh" : "",
+			              (si->appctx.ctx.stats.flags & STAT_HIDE_DOWN) ? ";up" : "",
+			              (si->appctx.ctx.stats.flags & STAT_NO_REFRESH) ? ";norefresh" : "",
 			              scope_txt);
 			break;
 		case STAT_STATUS_DENY:
@@ -3368,8 +3368,8 @@ static void stats_dump_html_info(struct stream_interface *si, struct uri_auth *u
 			              "<a class=lfsb href=\"%s%s%s%s\" title=\"Remove this message\">[X]</a> "
 			              "<b>Action denied.</b>"
 			              "</div>\n", uri->uri_prefix,
-			              (si->applet.ctx.stats.flags & STAT_HIDE_DOWN) ? ";up" : "",
-			              (si->applet.ctx.stats.flags & STAT_NO_REFRESH) ? ";norefresh" : "",
+			              (si->appctx.ctx.stats.flags & STAT_HIDE_DOWN) ? ";up" : "",
+			              (si->appctx.ctx.stats.flags & STAT_NO_REFRESH) ? ";norefresh" : "",
 			              scope_txt);
 			break;
 		default:
@@ -3378,8 +3378,8 @@ static void stats_dump_html_info(struct stream_interface *si, struct uri_auth *u
 			              "<a class=lfsb href=\"%s%s%s%s\" title=\"Remove this message\">[X]</a> "
 			              "Unexpected result."
 			              "</div>\n", uri->uri_prefix,
-			              (si->applet.ctx.stats.flags & STAT_HIDE_DOWN) ? ";up" : "",
-			              (si->applet.ctx.stats.flags & STAT_NO_REFRESH) ? ";norefresh" : "",
+			              (si->appctx.ctx.stats.flags & STAT_HIDE_DOWN) ? ";up" : "",
+			              (si->appctx.ctx.stats.flags & STAT_NO_REFRESH) ? ";norefresh" : "",
 			              scope_txt);
 		}
 		chunk_appendf(&trash, "<p>\n");
@@ -3408,13 +3408,13 @@ static int stats_dump_stat_to_buffer(struct stream_interface *si, struct uri_aut
 
 	chunk_reset(&trash);
 
-	switch (si->applet.st2) {
+	switch (si->appctx.st2) {
 	case STAT_ST_INIT:
-		si->applet.st2 = STAT_ST_HEAD; /* let's start producing data */
+		si->appctx.st2 = STAT_ST_HEAD; /* let's start producing data */
 		/* fall through */
 
 	case STAT_ST_HEAD:
-		if (si->applet.ctx.stats.flags & STAT_FMT_HTML)
+		if (si->appctx.ctx.stats.flags & STAT_FMT_HTML)
 			stats_dump_html_head(uri);
 		else
 			stats_dump_csv_header();
@@ -3422,49 +3422,49 @@ static int stats_dump_stat_to_buffer(struct stream_interface *si, struct uri_aut
 		if (bi_putchk(rep, &trash) == -1)
 			return 0;
 
-		si->applet.st2 = STAT_ST_INFO;
+		si->appctx.st2 = STAT_ST_INFO;
 		/* fall through */
 
 	case STAT_ST_INFO:
-		if (si->applet.ctx.stats.flags & STAT_FMT_HTML) {
+		if (si->appctx.ctx.stats.flags & STAT_FMT_HTML) {
 			stats_dump_html_info(si, uri);
 			if (bi_putchk(rep, &trash) == -1)
 				return 0;
 		}
 
-		si->applet.ctx.stats.px = proxy;
-		si->applet.ctx.stats.px_st = STAT_PX_ST_INIT;
-		si->applet.st2 = STAT_ST_LIST;
+		si->appctx.ctx.stats.px = proxy;
+		si->appctx.ctx.stats.px_st = STAT_PX_ST_INIT;
+		si->appctx.st2 = STAT_ST_LIST;
 		/* fall through */
 
 	case STAT_ST_LIST:
 		/* dump proxies */
-		while (si->applet.ctx.stats.px) {
+		while (si->appctx.ctx.stats.px) {
 			if (buffer_almost_full(rep->buf))
 				return 0;
 
-			px = si->applet.ctx.stats.px;
+			px = si->appctx.ctx.stats.px;
 			/* skip the disabled proxies, global frontend and non-networked ones */
 			if (px->state != PR_STSTOPPED && px->uuid > 0 && (px->cap & (PR_CAP_FE | PR_CAP_BE)))
 				if (stats_dump_proxy_to_buffer(si, px, uri) == 0)
 					return 0;
 
-			si->applet.ctx.stats.px = px->next;
-			si->applet.ctx.stats.px_st = STAT_PX_ST_INIT;
+			si->appctx.ctx.stats.px = px->next;
+			si->appctx.ctx.stats.px_st = STAT_PX_ST_INIT;
 		}
 		/* here, we just have reached the last proxy */
 
-		si->applet.st2 = STAT_ST_END;
+		si->appctx.st2 = STAT_ST_END;
 		/* fall through */
 
 	case STAT_ST_END:
-		if (si->applet.ctx.stats.flags & STAT_FMT_HTML) {
+		if (si->appctx.ctx.stats.flags & STAT_FMT_HTML) {
 			stats_dump_html_end();
 			if (bi_putchk(rep, &trash) == -1)
 				return 0;
 		}
 
-		si->applet.st2 = STAT_ST_FIN;
+		si->appctx.st2 = STAT_ST_FIN;
 		/* fall through */
 
 	case STAT_ST_FIN:
@@ -3472,7 +3472,7 @@ static int stats_dump_stat_to_buffer(struct stream_interface *si, struct uri_aut
 
 	default:
 		/* unknown state ! */
-		si->applet.st2 = STAT_ST_FIN;
+		si->appctx.st2 = STAT_ST_FIN;
 		return -1;
 	}
 }
@@ -3505,14 +3505,14 @@ static int stats_process_http_post(struct stream_interface *si)
 	temp = get_trash_chunk();
 	if (temp->size < s->txn.req.body_len) {
 		/* too large request */
-		si->applet.ctx.stats.st_code = STAT_STATUS_EXCD;
+		si->appctx.ctx.stats.st_code = STAT_STATUS_EXCD;
 		goto out;
 	}
 
 	reql = bo_getblk(si->ob, temp->str, s->txn.req.body_len, s->txn.req.eoh + 2);
 	if (reql <= 0) {
 		/* we need more data */
-		si->applet.ctx.stats.st_code = STAT_STATUS_NONE;
+		si->appctx.ctx.stats.st_code = STAT_STATUS_NONE;
 		return 0;
 	}
 
@@ -3521,7 +3521,7 @@ static int stats_process_http_post(struct stream_interface *si)
 	cur_param = next_param = end_params;
 	*end_params = '\0';
 
-	si->applet.ctx.stats.st_code = STAT_STATUS_NONE;
+	si->appctx.ctx.stats.st_code = STAT_STATUS_NONE;
 
 	/*
 	 * Parse the parameters in reverse order to only store the last value.
@@ -3542,7 +3542,7 @@ static int stats_process_http_post(struct stream_interface *si)
 				strncpy(key, cur_param + poffset, plen);
 				key[plen - 1] = '\0';
 			} else {
-				si->applet.ctx.stats.st_code = STAT_STATUS_EXCD;
+				si->appctx.ctx.stats.st_code = STAT_STATUS_EXCD;
 				goto out;
 			}
 
@@ -3562,7 +3562,7 @@ static int stats_process_http_post(struct stream_interface *si)
 			if (!px && (strcmp(key, "b") == 0)) {
 				if ((px = findproxy(value, PR_CAP_BE)) == NULL) {
 					/* the backend name is unknown or ambiguous (duplicate names) */
-					si->applet.ctx.stats.st_code = STAT_STATUS_ERRP;
+					si->appctx.ctx.stats.st_code = STAT_STATUS_ERRP;
 					goto out;
 				}
 			}
@@ -3583,7 +3583,7 @@ static int stats_process_http_post(struct stream_interface *si)
 					action = ST_ADM_ACTION_SHUTDOWN;
 				}
 				else {
-					si->applet.ctx.stats.st_code = STAT_STATUS_ERRP;
+					si->appctx.ctx.stats.st_code = STAT_STATUS_ERRP;
 					goto out;
 				}
 			}
@@ -3666,16 +3666,16 @@ static int stats_process_http_post(struct stream_interface *si)
 	}
 
 	if (total_servers == 0) {
-		si->applet.ctx.stats.st_code = STAT_STATUS_NONE;
+		si->appctx.ctx.stats.st_code = STAT_STATUS_NONE;
 	}
 	else if (altered_servers == 0) {
-		si->applet.ctx.stats.st_code = STAT_STATUS_ERRP;
+		si->appctx.ctx.stats.st_code = STAT_STATUS_ERRP;
 	}
 	else if (altered_servers == total_servers) {
-		si->applet.ctx.stats.st_code = STAT_STATUS_DONE;
+		si->appctx.ctx.stats.st_code = STAT_STATUS_DONE;
 	}
 	else {
-		si->applet.ctx.stats.st_code = STAT_STATUS_PART;
+		si->appctx.ctx.stats.st_code = STAT_STATUS_PART;
 	}
  out:
 	return 1;
@@ -3692,9 +3692,9 @@ static int stats_send_http_headers(struct stream_interface *si)
 		     "Cache-Control: no-cache\r\n"
 		     "Connection: close\r\n"
 		     "Content-Type: %s\r\n",
-		     (si->applet.ctx.stats.flags & STAT_FMT_HTML) ? "text/html" : "text/plain");
+		     (si->appctx.ctx.stats.flags & STAT_FMT_HTML) ? "text/html" : "text/plain");
 
-	if (uri->refresh > 0 && !(si->applet.ctx.stats.flags & STAT_NO_REFRESH))
+	if (uri->refresh > 0 && !(si->appctx.ctx.stats.flags & STAT_NO_REFRESH))
 		chunk_appendf(&trash, "Refresh: %d\r\n",
 			      uri->refresh);
 
@@ -3715,12 +3715,12 @@ static int stats_send_http_redirect(struct stream_interface *si)
 	struct session *s = session_from_task(si->owner);
 	struct uri_auth *uri = s->be->uri_auth;
 
-	/* scope_txt = search pattern + search query, si->applet.ctx.stats.scope_len is always <= STAT_SCOPE_TXT_MAXLEN */
+	/* scope_txt = search pattern + search query, si->appctx.ctx.stats.scope_len is always <= STAT_SCOPE_TXT_MAXLEN */
 	scope_txt[0] = 0;
-	if (si->applet.ctx.stats.scope_len) {
+	if (si->appctx.ctx.stats.scope_len) {
 		strcpy(scope_txt, STAT_SCOPE_PATTERN);
-		memcpy(scope_txt + strlen(STAT_SCOPE_PATTERN), bo_ptr(si->ob->buf) + si->applet.ctx.stats.scope_str, si->applet.ctx.stats.scope_len);
-		scope_txt[strlen(STAT_SCOPE_PATTERN) + si->applet.ctx.stats.scope_len] = 0;
+		memcpy(scope_txt + strlen(STAT_SCOPE_PATTERN), bo_ptr(si->ob->buf) + si->appctx.ctx.stats.scope_str, si->appctx.ctx.stats.scope_len);
+		scope_txt[strlen(STAT_SCOPE_PATTERN) + si->appctx.ctx.stats.scope_len] = 0;
 	}
 
 	/* We don't want to land on the posted stats page because a refresh will
@@ -3735,13 +3735,13 @@ static int stats_send_http_redirect(struct stream_interface *si)
 		     "Location: %s;st=%s%s%s%s\r\n"
 		     "\r\n",
 		     uri->uri_prefix,
-		     ((si->applet.ctx.stats.st_code > STAT_STATUS_INIT) &&
-		      (si->applet.ctx.stats.st_code < STAT_STATUS_SIZE) &&
-		      stat_status_codes[si->applet.ctx.stats.st_code]) ?
-		     stat_status_codes[si->applet.ctx.stats.st_code] :
+		     ((si->appctx.ctx.stats.st_code > STAT_STATUS_INIT) &&
+		      (si->appctx.ctx.stats.st_code < STAT_STATUS_SIZE) &&
+		      stat_status_codes[si->appctx.ctx.stats.st_code]) ?
+		     stat_status_codes[si->appctx.ctx.stats.st_code] :
 		     stat_status_codes[STAT_STATUS_UNKN],
-		     (si->applet.ctx.stats.flags & STAT_HIDE_DOWN) ? ";up" : "",
-		     (si->applet.ctx.stats.flags & STAT_NO_REFRESH) ? ";norefresh" : "",
+		     (si->appctx.ctx.stats.flags & STAT_HIDE_DOWN) ? ";up" : "",
+		     (si->appctx.ctx.stats.flags & STAT_NO_REFRESH) ? ";norefresh" : "",
 		     scope_txt);
 
 	s->txn.status = 303;
@@ -3755,7 +3755,7 @@ static int stats_send_http_redirect(struct stream_interface *si)
 
 /* This I/O handler runs as an applet embedded in a stream interface. It is
  * used to send HTTP stats over a TCP socket. The mechanism is very simple.
- * si->applet.st0 contains the operation in progress (dump, done). The handler
+ * si->appctx.st0 contains the operation in progress (dump, done). The handler
  * automatically unregisters itself once transfer is complete.
  */
 static void http_stats_io_handler(struct stream_interface *si)
@@ -3769,42 +3769,42 @@ static void http_stats_io_handler(struct stream_interface *si)
 
 	/* check that the output is not closed */
 	if (res->flags & (CF_SHUTW|CF_SHUTW_NOW))
-		si->applet.st0 = STAT_HTTP_DONE;
+		si->appctx.st0 = STAT_HTTP_DONE;
 
 	/* all states are processed in sequence */
-	if (si->applet.st0 == STAT_HTTP_HEAD) {
+	if (si->appctx.st0 == STAT_HTTP_HEAD) {
 		if (stats_send_http_headers(si)) {
 			if (s->txn.meth == HTTP_METH_HEAD)
-				si->applet.st0 = STAT_HTTP_DONE;
+				si->appctx.st0 = STAT_HTTP_DONE;
 			else
-				si->applet.st0 = STAT_HTTP_DUMP;
+				si->appctx.st0 = STAT_HTTP_DUMP;
 		}
 	}
 
-	if (si->applet.st0 == STAT_HTTP_DUMP) {
+	if (si->appctx.st0 == STAT_HTTP_DUMP) {
 		if (stats_dump_stat_to_buffer(si, s->be->uri_auth))
-			si->applet.st0 = STAT_HTTP_DONE;
+			si->appctx.st0 = STAT_HTTP_DONE;
 	}
 
-	if (si->applet.st0 == STAT_HTTP_POST) {
+	if (si->appctx.st0 == STAT_HTTP_POST) {
 		if (stats_process_http_post(si))
-			si->applet.st0 = STAT_HTTP_LAST;
+			si->appctx.st0 = STAT_HTTP_LAST;
 		else if (si->ob->flags & CF_SHUTR)
-			si->applet.st0 = STAT_HTTP_DONE;
+			si->appctx.st0 = STAT_HTTP_DONE;
 	}
 
-	if (si->applet.st0 == STAT_HTTP_LAST) {
+	if (si->appctx.st0 == STAT_HTTP_LAST) {
 		if (stats_send_http_redirect(si))
-			si->applet.st0 = STAT_HTTP_DONE;
+			si->appctx.st0 = STAT_HTTP_DONE;
 	}
 
-	if (si->applet.st0 == STAT_HTTP_DONE)
+	if (si->appctx.st0 == STAT_HTTP_DONE)
 		si_shutw(si);
 
 	if ((res->flags & CF_SHUTR) && (si->state == SI_ST_EST))
 		si_shutw(si);
 
-	if (si->applet.st0 == STAT_HTTP_DONE) {
+	if (si->appctx.st0 == STAT_HTTP_DONE) {
 		if ((req->flags & CF_SHUTW) && (si->state == SI_ST_EST)) {
 			si_shutr(si);
 			res->flags |= CF_READ_NULL;
@@ -3884,20 +3884,20 @@ static int stats_dump_full_sess_to_buffer(struct stream_interface *si, struct se
 
 	chunk_reset(&trash);
 
-	if (si->applet.ctx.sess.section > 0 && si->applet.ctx.sess.uid != sess->uniq_id) {
+	if (si->appctx.ctx.sess.section > 0 && si->appctx.ctx.sess.uid != sess->uniq_id) {
 		/* session changed, no need to go any further */
 		chunk_appendf(&trash, "  *** session terminated while we were watching it ***\n");
 		if (bi_putchk(si->ib, &trash) == -1)
 			return 0;
-		si->applet.ctx.sess.uid = 0;
-		si->applet.ctx.sess.section = 0;
+		si->appctx.ctx.sess.uid = 0;
+		si->appctx.ctx.sess.section = 0;
 		return 1;
 	}
 
-	switch (si->applet.ctx.sess.section) {
+	switch (si->appctx.ctx.sess.section) {
 	case 0: /* main status of the session */
-		si->applet.ctx.sess.uid = sess->uniq_id;
-		si->applet.ctx.sess.section = 1;
+		si->appctx.ctx.sess.uid = sess->uniq_id;
+		si->appctx.ctx.sess.section = 1;
 		/* fall through */
 
 	case 1:
@@ -4141,8 +4141,8 @@ static int stats_dump_full_sess_to_buffer(struct stream_interface *si, struct se
 		/* use other states to dump the contents */
 	}
 	/* end of dump */
-	si->applet.ctx.sess.uid = 0;
-	si->applet.ctx.sess.section = 0;
+	si->appctx.ctx.sess.uid = 0;
+	si->appctx.ctx.sess.section = 0;
 	return 1;
 }
 
@@ -4157,10 +4157,10 @@ static int stats_dump_sess_to_buffer(struct stream_interface *si)
 		/* If we're forced to shut down, we might have to remove our
 		 * reference to the last session being dumped.
 		 */
-		if (si->applet.st2 == STAT_ST_LIST) {
-			if (!LIST_ISEMPTY(&si->applet.ctx.sess.bref.users)) {
-				LIST_DEL(&si->applet.ctx.sess.bref.users);
-				LIST_INIT(&si->applet.ctx.sess.bref.users);
+		if (si->appctx.st2 == STAT_ST_LIST) {
+			if (!LIST_ISEMPTY(&si->appctx.ctx.sess.bref.users)) {
+				LIST_DEL(&si->appctx.ctx.sess.bref.users);
+				LIST_INIT(&si->appctx.ctx.sess.bref.users);
 			}
 		}
 		return 1;
@@ -4168,7 +4168,7 @@ static int stats_dump_sess_to_buffer(struct stream_interface *si)
 
 	chunk_reset(&trash);
 
-	switch (si->applet.st2) {
+	switch (si->appctx.st2) {
 	case STAT_ST_INIT:
 		/* the function had not been called yet, let's prepare the
 		 * buffer for a response. We initialize the current session
@@ -4177,39 +4177,39 @@ static int stats_dump_sess_to_buffer(struct stream_interface *si)
 		 * this pointer. We know we have reached the end when this
 		 * pointer points back to the head of the sessions list.
 		 */
-		LIST_INIT(&si->applet.ctx.sess.bref.users);
-		si->applet.ctx.sess.bref.ref = sessions.n;
-		si->applet.st2 = STAT_ST_LIST;
+		LIST_INIT(&si->appctx.ctx.sess.bref.users);
+		si->appctx.ctx.sess.bref.ref = sessions.n;
+		si->appctx.st2 = STAT_ST_LIST;
 		/* fall through */
 
 	case STAT_ST_LIST:
 		/* first, let's detach the back-ref from a possible previous session */
-		if (!LIST_ISEMPTY(&si->applet.ctx.sess.bref.users)) {
-			LIST_DEL(&si->applet.ctx.sess.bref.users);
-			LIST_INIT(&si->applet.ctx.sess.bref.users);
+		if (!LIST_ISEMPTY(&si->appctx.ctx.sess.bref.users)) {
+			LIST_DEL(&si->appctx.ctx.sess.bref.users);
+			LIST_INIT(&si->appctx.ctx.sess.bref.users);
 		}
 
 		/* and start from where we stopped */
-		while (si->applet.ctx.sess.bref.ref != &sessions) {
+		while (si->appctx.ctx.sess.bref.ref != &sessions) {
 			char pn[INET6_ADDRSTRLEN];
 			struct session *curr_sess;
 
-			curr_sess = LIST_ELEM(si->applet.ctx.sess.bref.ref, struct session *, list);
+			curr_sess = LIST_ELEM(si->appctx.ctx.sess.bref.ref, struct session *, list);
 
-			if (si->applet.ctx.sess.target) {
-				if (si->applet.ctx.sess.target != (void *)-1 && si->applet.ctx.sess.target != curr_sess)
+			if (si->appctx.ctx.sess.target) {
+				if (si->appctx.ctx.sess.target != (void *)-1 && si->appctx.ctx.sess.target != curr_sess)
 					goto next_sess;
 
-				LIST_ADDQ(&curr_sess->back_refs, &si->applet.ctx.sess.bref.users);
+				LIST_ADDQ(&curr_sess->back_refs, &si->appctx.ctx.sess.bref.users);
 				/* call the proper dump() function and return if we're missing space */
 				if (!stats_dump_full_sess_to_buffer(si, curr_sess))
 					return 0;
 
 				/* session dump complete */
-				LIST_DEL(&si->applet.ctx.sess.bref.users);
-				LIST_INIT(&si->applet.ctx.sess.bref.users);
-				if (si->applet.ctx.sess.target != (void *)-1) {
-					si->applet.ctx.sess.target = NULL;
+				LIST_DEL(&si->appctx.ctx.sess.bref.users);
+				LIST_INIT(&si->appctx.ctx.sess.bref.users);
+				if (si->appctx.ctx.sess.target != (void *)-1) {
+					si->appctx.ctx.sess.target = NULL;
 					break;
 				}
 				else
@@ -4325,17 +4325,17 @@ static int stats_dump_sess_to_buffer(struct stream_interface *si)
 				/* let's try again later from this session. We add ourselves into
 				 * this session's users so that it can remove us upon termination.
 				 */
-				LIST_ADDQ(&curr_sess->back_refs, &si->applet.ctx.sess.bref.users);
+				LIST_ADDQ(&curr_sess->back_refs, &si->appctx.ctx.sess.bref.users);
 				return 0;
 			}
 
 		next_sess:
-			si->applet.ctx.sess.bref.ref = curr_sess->list.n;
+			si->appctx.ctx.sess.bref.ref = curr_sess->list.n;
 		}
 
-		if (si->applet.ctx.sess.target && si->applet.ctx.sess.target != (void *)-1) {
+		if (si->appctx.ctx.sess.target && si->appctx.ctx.sess.target != (void *)-1) {
 			/* specified session not found */
-			if (si->applet.ctx.sess.section > 0)
+			if (si->appctx.ctx.sess.section > 0)
 				chunk_appendf(&trash, "  *** session terminated while we were watching it ***\n");
 			else
 				chunk_appendf(&trash, "Session not found.\n");
@@ -4343,16 +4343,16 @@ static int stats_dump_sess_to_buffer(struct stream_interface *si)
 			if (bi_putchk(si->ib, &trash) == -1)
 				return 0;
 
-			si->applet.ctx.sess.target = NULL;
-			si->applet.ctx.sess.uid = 0;
+			si->appctx.ctx.sess.target = NULL;
+			si->appctx.ctx.sess.uid = 0;
 			return 1;
 		}
 
-		si->applet.st2 = STAT_ST_FIN;
+		si->appctx.st2 = STAT_ST_FIN;
 		/* fall through */
 
 	default:
-		si->applet.st2 = STAT_ST_FIN;
+		si->appctx.st2 = STAT_ST_FIN;
 		return 1;
 	}
 }
@@ -4363,9 +4363,9 @@ static int stats_dump_sess_to_buffer(struct stream_interface *si)
  */
 static void cli_release_handler(struct stream_interface *si)
 {
-	if (si->applet.st0 == STAT_CLI_O_SESS && si->applet.st2 == STAT_ST_LIST) {
-		if (!LIST_ISEMPTY(&si->applet.ctx.sess.bref.users))
-			LIST_DEL(&si->applet.ctx.sess.bref.users);
+	if (si->appctx.st0 == STAT_CLI_O_SESS && si->appctx.st2 == STAT_ST_LIST) {
+		if (!LIST_ISEMPTY(&si->appctx.ctx.sess.bref.users))
+			LIST_DEL(&si->appctx.ctx.sess.bref.users);
 	}
 }
 
@@ -4383,7 +4383,7 @@ static int stats_table_request(struct stream_interface *si, int action)
 	int show = action == STAT_CLI_O_TAB;
 
 	/*
-	 * We have 3 possible states in si->applet.st2 :
+	 * We have 3 possible states in si->appctx.st2 :
 	 *   - STAT_ST_INIT : the first call
 	 *   - STAT_ST_INFO : the proxy pointer points to the next table to
 	 *     dump, the entry pointer is NULL ;
@@ -4396,65 +4396,65 @@ static int stats_table_request(struct stream_interface *si, int action)
 
 	if (unlikely(si->ib->flags & (CF_WRITE_ERROR|CF_SHUTW))) {
 		/* in case of abort, remove any refcount we might have set on an entry */
-		if (si->applet.st2 == STAT_ST_LIST) {
-			si->applet.ctx.table.entry->ref_cnt--;
-			stksess_kill_if_expired(&si->applet.ctx.table.proxy->table, si->applet.ctx.table.entry);
+		if (si->appctx.st2 == STAT_ST_LIST) {
+			si->appctx.ctx.table.entry->ref_cnt--;
+			stksess_kill_if_expired(&si->appctx.ctx.table.proxy->table, si->appctx.ctx.table.entry);
 		}
 		return 1;
 	}
 
 	chunk_reset(&trash);
 
-	while (si->applet.st2 != STAT_ST_FIN) {
-		switch (si->applet.st2) {
+	while (si->appctx.st2 != STAT_ST_FIN) {
+		switch (si->appctx.st2) {
 		case STAT_ST_INIT:
-			si->applet.ctx.table.proxy = si->applet.ctx.table.target;
-			if (!si->applet.ctx.table.proxy)
-				si->applet.ctx.table.proxy = proxy;
+			si->appctx.ctx.table.proxy = si->appctx.ctx.table.target;
+			if (!si->appctx.ctx.table.proxy)
+				si->appctx.ctx.table.proxy = proxy;
 
-			si->applet.ctx.table.entry = NULL;
-			si->applet.st2 = STAT_ST_INFO;
+			si->appctx.ctx.table.entry = NULL;
+			si->appctx.st2 = STAT_ST_INFO;
 			break;
 
 		case STAT_ST_INFO:
-			if (!si->applet.ctx.table.proxy ||
-			    (si->applet.ctx.table.target &&
-			     si->applet.ctx.table.proxy != si->applet.ctx.table.target)) {
-				si->applet.st2 = STAT_ST_END;
+			if (!si->appctx.ctx.table.proxy ||
+			    (si->appctx.ctx.table.target &&
+			     si->appctx.ctx.table.proxy != si->appctx.ctx.table.target)) {
+				si->appctx.st2 = STAT_ST_END;
 				break;
 			}
 
-			if (si->applet.ctx.table.proxy->table.size) {
-				if (show && !stats_dump_table_head_to_buffer(&trash, si, si->applet.ctx.table.proxy,
-									     si->applet.ctx.table.target))
+			if (si->appctx.ctx.table.proxy->table.size) {
+				if (show && !stats_dump_table_head_to_buffer(&trash, si, si->appctx.ctx.table.proxy,
+									     si->appctx.ctx.table.target))
 					return 0;
 
-				if (si->applet.ctx.table.target &&
+				if (si->appctx.ctx.table.target &&
 				    s->listener->bind_conf->level >= ACCESS_LVL_OPER) {
 					/* dump entries only if table explicitly requested */
-					eb = ebmb_first(&si->applet.ctx.table.proxy->table.keys);
+					eb = ebmb_first(&si->appctx.ctx.table.proxy->table.keys);
 					if (eb) {
-						si->applet.ctx.table.entry = ebmb_entry(eb, struct stksess, key);
-						si->applet.ctx.table.entry->ref_cnt++;
-						si->applet.st2 = STAT_ST_LIST;
+						si->appctx.ctx.table.entry = ebmb_entry(eb, struct stksess, key);
+						si->appctx.ctx.table.entry->ref_cnt++;
+						si->appctx.st2 = STAT_ST_LIST;
 						break;
 					}
 				}
 			}
-			si->applet.ctx.table.proxy = si->applet.ctx.table.proxy->next;
+			si->appctx.ctx.table.proxy = si->appctx.ctx.table.proxy->next;
 			break;
 
 		case STAT_ST_LIST:
 			skip_entry = 0;
 
-			if (si->applet.ctx.table.data_type >= 0) {
+			if (si->appctx.ctx.table.data_type >= 0) {
 				/* we're filtering on some data contents */
 				void *ptr;
 				long long data;
 
-				dt = si->applet.ctx.table.data_type;
-				ptr = stktable_data_ptr(&si->applet.ctx.table.proxy->table,
-							si->applet.ctx.table.entry,
+				dt = si->appctx.ctx.table.data_type;
+				ptr = stktable_data_ptr(&si->appctx.ctx.table.proxy->table,
+							si->appctx.ctx.table.entry,
 							dt);
 
 				data = 0;
@@ -4470,57 +4470,57 @@ static int stats_table_request(struct stream_interface *si, int action)
 					break;
 				case STD_T_FRQP:
 					data = read_freq_ctr_period(&stktable_data_cast(ptr, std_t_frqp),
-								    si->applet.ctx.table.proxy->table.data_arg[dt].u);
+								    si->appctx.ctx.table.proxy->table.data_arg[dt].u);
 					break;
 				}
 
 				/* skip the entry if the data does not match the test and the value */
-				if ((data < si->applet.ctx.table.value &&
-				     (si->applet.ctx.table.data_op == STD_OP_EQ ||
-				      si->applet.ctx.table.data_op == STD_OP_GT ||
-				      si->applet.ctx.table.data_op == STD_OP_GE)) ||
-				    (data == si->applet.ctx.table.value &&
-				     (si->applet.ctx.table.data_op == STD_OP_NE ||
-				      si->applet.ctx.table.data_op == STD_OP_GT ||
-				      si->applet.ctx.table.data_op == STD_OP_LT)) ||
-				    (data > si->applet.ctx.table.value &&
-				     (si->applet.ctx.table.data_op == STD_OP_EQ ||
-				      si->applet.ctx.table.data_op == STD_OP_LT ||
-				      si->applet.ctx.table.data_op == STD_OP_LE)))
+				if ((data < si->appctx.ctx.table.value &&
+				     (si->appctx.ctx.table.data_op == STD_OP_EQ ||
+				      si->appctx.ctx.table.data_op == STD_OP_GT ||
+				      si->appctx.ctx.table.data_op == STD_OP_GE)) ||
+				    (data == si->appctx.ctx.table.value &&
+				     (si->appctx.ctx.table.data_op == STD_OP_NE ||
+				      si->appctx.ctx.table.data_op == STD_OP_GT ||
+				      si->appctx.ctx.table.data_op == STD_OP_LT)) ||
+				    (data > si->appctx.ctx.table.value &&
+				     (si->appctx.ctx.table.data_op == STD_OP_EQ ||
+				      si->appctx.ctx.table.data_op == STD_OP_LT ||
+				      si->appctx.ctx.table.data_op == STD_OP_LE)))
 					skip_entry = 1;
 			}
 
 			if (show && !skip_entry &&
-			    !stats_dump_table_entry_to_buffer(&trash, si, si->applet.ctx.table.proxy,
-							      si->applet.ctx.table.entry))
+			    !stats_dump_table_entry_to_buffer(&trash, si, si->appctx.ctx.table.proxy,
+							      si->appctx.ctx.table.entry))
 			    return 0;
 
-			si->applet.ctx.table.entry->ref_cnt--;
+			si->appctx.ctx.table.entry->ref_cnt--;
 
-			eb = ebmb_next(&si->applet.ctx.table.entry->key);
+			eb = ebmb_next(&si->appctx.ctx.table.entry->key);
 			if (eb) {
-				struct stksess *old = si->applet.ctx.table.entry;
-				si->applet.ctx.table.entry = ebmb_entry(eb, struct stksess, key);
+				struct stksess *old = si->appctx.ctx.table.entry;
+				si->appctx.ctx.table.entry = ebmb_entry(eb, struct stksess, key);
 				if (show)
-					stksess_kill_if_expired(&si->applet.ctx.table.proxy->table, old);
-				else if (!skip_entry && !si->applet.ctx.table.entry->ref_cnt)
-					stksess_kill(&si->applet.ctx.table.proxy->table, old);
-				si->applet.ctx.table.entry->ref_cnt++;
+					stksess_kill_if_expired(&si->appctx.ctx.table.proxy->table, old);
+				else if (!skip_entry && !si->appctx.ctx.table.entry->ref_cnt)
+					stksess_kill(&si->appctx.ctx.table.proxy->table, old);
+				si->appctx.ctx.table.entry->ref_cnt++;
 				break;
 			}
 
 
 			if (show)
-				stksess_kill_if_expired(&si->applet.ctx.table.proxy->table, si->applet.ctx.table.entry);
-			else if (!skip_entry && !si->applet.ctx.table.entry->ref_cnt)
-				stksess_kill(&si->applet.ctx.table.proxy->table, si->applet.ctx.table.entry);
+				stksess_kill_if_expired(&si->appctx.ctx.table.proxy->table, si->appctx.ctx.table.entry);
+			else if (!skip_entry && !si->appctx.ctx.table.entry->ref_cnt)
+				stksess_kill(&si->appctx.ctx.table.proxy->table, si->appctx.ctx.table.entry);
 
-			si->applet.ctx.table.proxy = si->applet.ctx.table.proxy->next;
-			si->applet.st2 = STAT_ST_INFO;
+			si->appctx.ctx.table.proxy = si->appctx.ctx.table.proxy->next;
+			si->appctx.st2 = STAT_ST_INFO;
 			break;
 
 		case STAT_ST_END:
-			si->applet.st2 = STAT_ST_FIN;
+			si->appctx.st2 = STAT_ST_FIN;
 			break;
 		}
 	}
@@ -4598,7 +4598,7 @@ static int stats_dump_errors_to_buffer(struct stream_interface *si)
 
 	chunk_reset(&trash);
 
-	if (!si->applet.ctx.errors.px) {
+	if (!si->appctx.ctx.errors.px) {
 		/* the function had not been called yet, let's prepare the
 		 * buffer for a response.
 		 */
@@ -4615,32 +4615,32 @@ static int stats_dump_errors_to_buffer(struct stream_interface *si)
 			return 0;
 		}
 
-		si->applet.ctx.errors.px = proxy;
-		si->applet.ctx.errors.buf = 0;
-		si->applet.ctx.errors.bol = 0;
-		si->applet.ctx.errors.ptr = -1;
+		si->appctx.ctx.errors.px = proxy;
+		si->appctx.ctx.errors.buf = 0;
+		si->appctx.ctx.errors.bol = 0;
+		si->appctx.ctx.errors.ptr = -1;
 	}
 
 	/* we have two inner loops here, one for the proxy, the other one for
 	 * the buffer.
 	 */
-	while (si->applet.ctx.errors.px) {
+	while (si->appctx.ctx.errors.px) {
 		struct error_snapshot *es;
 
-		if (si->applet.ctx.errors.buf == 0)
-			es = &si->applet.ctx.errors.px->invalid_req;
+		if (si->appctx.ctx.errors.buf == 0)
+			es = &si->appctx.ctx.errors.px->invalid_req;
 		else
-			es = &si->applet.ctx.errors.px->invalid_rep;
+			es = &si->appctx.ctx.errors.px->invalid_rep;
 
 		if (!es->when.tv_sec)
 			goto next;
 
-		if (si->applet.ctx.errors.iid >= 0 &&
-		    si->applet.ctx.errors.px->uuid != si->applet.ctx.errors.iid &&
-		    es->oe->uuid != si->applet.ctx.errors.iid)
+		if (si->appctx.ctx.errors.iid >= 0 &&
+		    si->appctx.ctx.errors.px->uuid != si->appctx.ctx.errors.iid &&
+		    es->oe->uuid != si->appctx.ctx.errors.iid)
 			goto next;
 
-		if (si->applet.ctx.errors.ptr < 0) {
+		if (si->appctx.ctx.errors.ptr < 0) {
 			/* just print headers now */
 
 			char pn[INET6_ADDRSTRLEN];
@@ -4661,12 +4661,12 @@ static int stats_dump_errors_to_buffer(struct stream_interface *si)
 				port = 0;
 			}
 
-			switch (si->applet.ctx.errors.buf) {
+			switch (si->appctx.ctx.errors.buf) {
 			case 0:
 				chunk_appendf(&trash,
 					     " frontend %s (#%d): invalid request\n"
 					     "  backend %s (#%d)",
-					     si->applet.ctx.errors.px->id, si->applet.ctx.errors.px->uuid,
+					     si->appctx.ctx.errors.px->id, si->appctx.ctx.errors.px->uuid,
 					     (es->oe->cap & PR_CAP_BE) ? es->oe->id : "<NONE>",
 					     (es->oe->cap & PR_CAP_BE) ? es->oe->uuid : -1);
 				break;
@@ -4674,7 +4674,7 @@ static int stats_dump_errors_to_buffer(struct stream_interface *si)
 				chunk_appendf(&trash,
 					     " backend %s (#%d) : invalid response\n"
 					     "  frontend %s (#%d)",
-					     si->applet.ctx.errors.px->id, si->applet.ctx.errors.px->uuid,
+					     si->appctx.ctx.errors.px->id, si->appctx.ctx.errors.px->uuid,
 					     es->oe->id, es->oe->uuid);
 				break;
 			}
@@ -4698,11 +4698,11 @@ static int stats_dump_errors_to_buffer(struct stream_interface *si)
 				/* Socket buffer full. Let's try again later from the same point */
 				return 0;
 			}
-			si->applet.ctx.errors.ptr = 0;
-			si->applet.ctx.errors.sid = es->sid;
+			si->appctx.ctx.errors.ptr = 0;
+			si->appctx.ctx.errors.sid = es->sid;
 		}
 
-		if (si->applet.ctx.errors.sid != es->sid) {
+		if (si->appctx.ctx.errors.sid != es->sid) {
 			/* the snapshot changed while we were dumping it */
 			chunk_appendf(&trash,
 				     "  WARNING! update detected on this snapshot, dump interrupted. Please re-check!\n");
@@ -4712,29 +4712,29 @@ static int stats_dump_errors_to_buffer(struct stream_interface *si)
 		}
 
 		/* OK, ptr >= 0, so we have to dump the current line */
-		while (si->applet.ctx.errors.ptr < es->len && si->applet.ctx.errors.ptr < sizeof(es->buf)) {
+		while (si->appctx.ctx.errors.ptr < es->len && si->appctx.ctx.errors.ptr < sizeof(es->buf)) {
 			int newptr;
 			int newline;
 
-			newline = si->applet.ctx.errors.bol;
-			newptr = dump_text_line(&trash, es->buf, sizeof(es->buf), es->len, &newline, si->applet.ctx.errors.ptr);
-			if (newptr == si->applet.ctx.errors.ptr)
+			newline = si->appctx.ctx.errors.bol;
+			newptr = dump_text_line(&trash, es->buf, sizeof(es->buf), es->len, &newline, si->appctx.ctx.errors.ptr);
+			if (newptr == si->appctx.ctx.errors.ptr)
 				return 0;
 
 			if (bi_putchk(si->ib, &trash) == -1) {
 				/* Socket buffer full. Let's try again later from the same point */
 				return 0;
 			}
-			si->applet.ctx.errors.ptr = newptr;
-			si->applet.ctx.errors.bol = newline;
+			si->appctx.ctx.errors.ptr = newptr;
+			si->appctx.ctx.errors.bol = newline;
 		};
 	next:
-		si->applet.ctx.errors.bol = 0;
-		si->applet.ctx.errors.ptr = -1;
-		si->applet.ctx.errors.buf++;
-		if (si->applet.ctx.errors.buf > 1) {
-			si->applet.ctx.errors.buf = 0;
-			si->applet.ctx.errors.px = si->applet.ctx.errors.px->next;
+		si->appctx.ctx.errors.bol = 0;
+		si->appctx.ctx.errors.ptr = -1;
+		si->appctx.ctx.errors.buf++;
+		if (si->appctx.ctx.errors.buf > 1) {
+			si->appctx.ctx.errors.buf = 0;
+			si->appctx.ctx.errors.px = si->appctx.ctx.errors.px->next;
 		}
 	}
 
diff --git a/src/peers.c b/src/peers.c
index 6ef4aa5..43d7249 100644
--- a/src/peers.c
+++ b/src/peers.c
@@ -184,10 +184,10 @@ static int peer_prepare_datamsg(struct stksess *ts, struct peer_session *ps, cha
 static void peer_session_release(struct stream_interface *si)
 {
 	struct session *s = session_from_task(si->owner);
-	struct peer_session *ps = (struct peer_session *)si->applet.ctx.peers.ptr;
+	struct peer_session *ps = (struct peer_session *)si->appctx.ctx.peers.ptr;
 
-	/* si->applet.ctx.peers.ptr is not a peer session */
-	if (si->applet.st0 < PEER_SESSION_SENDSUCCESS)
+	/* si->appctx.ctx.peers.ptr is not a peer session */
+	if (si->appctx.st0 < PEER_SESSION_SENDSUCCESS)
 		return;
 
 	/* peer session identified */
@@ -223,21 +223,21 @@ static void peer_io_handler(struct stream_interface *si)
 
 	while (1) {
 switchstate:
-		switch(si->applet.st0) {
+		switch(si->appctx.st0) {
 			case PEER_SESSION_ACCEPT:
-				si->applet.ctx.peers.ptr = NULL;
-				si->applet.st0 = PEER_SESSION_GETVERSION;
+				si->appctx.ctx.peers.ptr = NULL;
+				si->appctx.st0 = PEER_SESSION_GETVERSION;
 				/* fall through */
 			case PEER_SESSION_GETVERSION:
 				reql = bo_getline(si->ob, trash.str, trash.size);
 				if (reql <= 0) { /* closed or EOL not found */
 					if (reql == 0)
 						goto out;
-					si->applet.st0 = PEER_SESSION_END;
+					si->appctx.st0 = PEER_SESSION_END;
 					goto switchstate;
 				}
 				if (trash.str[reql-1] != '\n') {
-					si->applet.st0 = PEER_SESSION_END;
+					si->appctx.st0 = PEER_SESSION_END;
 					goto switchstate;
 				}
 				else if (reql > 1 && (trash.str[reql-2] == '\r'))
@@ -249,26 +249,26 @@ switchstate:
 
 				/* test version */
 				if (strcmp(PEER_SESSION_PROTO_NAME " 1.0", trash.str) != 0) {
-					si->applet.st0 = PEER_SESSION_EXIT;
-					si->applet.st1 = PEER_SESSION_ERRVERSION;
+					si->appctx.st0 = PEER_SESSION_EXIT;
+					si->appctx.st1 = PEER_SESSION_ERRVERSION;
 					/* test protocol */
 					if (strncmp(PEER_SESSION_PROTO_NAME " ", trash.str, strlen(PEER_SESSION_PROTO_NAME)+1) != 0)
-						si->applet.st1 = PEER_SESSION_ERRPROTO;
+						si->appctx.st1 = PEER_SESSION_ERRPROTO;
 					goto switchstate;
 				}
 
-				si->applet.st0 = PEER_SESSION_GETHOST;
+				si->appctx.st0 = PEER_SESSION_GETHOST;
 				/* fall through */
 			case PEER_SESSION_GETHOST:
 				reql = bo_getline(si->ob, trash.str, trash.size);
 				if (reql <= 0) { /* closed or EOL not found */
 					if (reql == 0)
 						goto out;
-					si->applet.st0 = PEER_SESSION_END;
+					si->appctx.st0 = PEER_SESSION_END;
 					goto switchstate;
 				}
 				if (trash.str[reql-1] != '\n') {
-					si->applet.st0 = PEER_SESSION_END;
+					si->appctx.st0 = PEER_SESSION_END;
 					goto switchstate;
 				}
 				else if (reql > 1 && (trash.str[reql-2] == '\r'))
@@ -280,12 +280,12 @@ switchstate:
 
 				/* test hostname match */
 				if (strcmp(localpeer, trash.str) != 0) {
-					si->applet.st0 = PEER_SESSION_EXIT;
-					si->applet.st1 = PEER_SESSION_ERRHOST;
+					si->appctx.st0 = PEER_SESSION_EXIT;
+					si->appctx.st1 = PEER_SESSION_ERRHOST;
 					goto switchstate;
 				}
 
-				si->applet.st0 = PEER_SESSION_GETPEER;
+				si->appctx.st0 = PEER_SESSION_GETPEER;
 				/* fall through */
 			case PEER_SESSION_GETPEER: {
 				struct peer *curpeer;
@@ -294,12 +294,12 @@ switchstate:
 				if (reql <= 0) { /* closed or EOL not found */
 					if (reql == 0)
 						goto out;
-					si->applet.st0 = PEER_SESSION_END;
+					si->appctx.st0 = PEER_SESSION_END;
 					goto switchstate;
 				}
 				if (trash.str[reql-1] != '\n') {
 					/* Incomplete line, we quit */
-					si->applet.st0 = PEER_SESSION_END;
+					si->appctx.st0 = PEER_SESSION_END;
 					goto switchstate;
 				}
 				else if (reql > 1 && (trash.str[reql-2] == '\r'))
@@ -312,8 +312,8 @@ switchstate:
 				/* parse line "<peer name> <pid>" */
 				p = strchr(trash.str, ' ');
 				if (!p) {
-					si->applet.st0 = PEER_SESSION_EXIT;
-					si->applet.st1 = PEER_SESSION_ERRPROTO;
+					si->appctx.st0 = PEER_SESSION_EXIT;
+					si->appctx.st1 = PEER_SESSION_ERRPROTO;
 					goto switchstate;
 				}
 				*p = 0;
@@ -326,17 +326,17 @@ switchstate:
 
 				/* if unknown peer */
 				if (!curpeer) {
-					si->applet.st0 = PEER_SESSION_EXIT;
-					si->applet.st1 = PEER_SESSION_ERRPEER;
+					si->appctx.st0 = PEER_SESSION_EXIT;
+					si->appctx.st1 = PEER_SESSION_ERRPEER;
 					goto switchstate;
 				}
 
-				si->applet.ctx.peers.ptr = curpeer;
-				si->applet.st0 = PEER_SESSION_GETTABLE;
+				si->appctx.ctx.peers.ptr = curpeer;
+				si->appctx.st0 = PEER_SESSION_GETTABLE;
 				/* fall through */
 			}
 			case PEER_SESSION_GETTABLE: {
-				struct peer *curpeer = (struct peer *)si->applet.ctx.peers.ptr;
+				struct peer *curpeer = (struct peer *)si->appctx.ctx.peers.ptr;
 				struct shared_table *st;
 				struct peer_session *ps = NULL;
 				unsigned long key_type;
@@ -347,16 +347,16 @@ switchstate:
 				if (reql <= 0) { /* closed or EOL not found */
 					if (reql == 0)
 						goto out;
-					si->applet.ctx.peers.ptr = NULL;
-					si->applet.st0 = PEER_SESSION_END;
+					si->appctx.ctx.peers.ptr = NULL;
+					si->appctx.st0 = PEER_SESSION_END;
 					goto switchstate;
 				}
-				/* Re init si->applet.ctx.peers.ptr to null, to handle correctly a release case */
-				si->applet.ctx.peers.ptr = NULL;
+				/* Re init si->appctx.ctx.peers.ptr to null, to handle correctly a release case */
+				si->appctx.ctx.peers.ptr = NULL;
 
 				if (trash.str[reql-1] != '\n') {
 					/* Incomplete line, we quit */
-					si->applet.st0 = PEER_SESSION_END;
+					si->appctx.st0 = PEER_SESSION_END;
 					goto switchstate;
 				}
 				else if (reql > 1 && (trash.str[reql-2] == '\r'))
@@ -369,8 +369,8 @@ switchstate:
 				/* Parse line "<table name> <type> <size>" */
 				p = strchr(trash.str, ' ');
 				if (!p) {
-					si->applet.st0 = PEER_SESSION_EXIT;
-					si->applet.st1 = PEER_SESSION_ERRPROTO;
+					si->appctx.st0 = PEER_SESSION_EXIT;
+					si->appctx.st1 = PEER_SESSION_ERRPROTO;
 					goto switchstate;
 				}
 				*p = 0;
@@ -378,9 +378,9 @@ switchstate:
 
 				p = strchr(p+1, ' ');
 				if (!p) {
-					si->applet.ctx.peers.ptr = NULL;
-					si->applet.st0 = PEER_SESSION_EXIT;
-					si->applet.st1 = PEER_SESSION_ERRPROTO;
+					si->appctx.ctx.peers.ptr = NULL;
+					si->appctx.st0 = PEER_SESSION_EXIT;
+					si->appctx.st1 = PEER_SESSION_ERRPROTO;
 					goto switchstate;
 				}
 
@@ -395,15 +395,15 @@ switchstate:
 						if (key_size != st->table->key_size &&
 						    (key_type != STKTABLE_TYPE_STRING ||
 						     1 + 4 + 4 + key_size - 1 >= trash.size)) {
-							si->applet.st0 = PEER_SESSION_EXIT;
-							si->applet.st1 = PEER_SESSION_ERRSIZE;
+							si->appctx.st0 = PEER_SESSION_EXIT;
+							si->appctx.st1 = PEER_SESSION_ERRSIZE;
 							goto switchstate;
 						}
 
 						/* If key type mismatches */
 						if (key_type != st->table->type) {
-							si->applet.st0 = PEER_SESSION_EXIT;
-							si->applet.st1 = PEER_SESSION_ERRTYPE;
+							si->appctx.st0 = PEER_SESSION_EXIT;
+							si->appctx.st1 = PEER_SESSION_ERRTYPE;
 							goto switchstate;
 						}
 
@@ -414,8 +414,8 @@ switchstate:
 								if (ps->session && ps->session != s) {
 									if (ps->peer->local) {
 										/* Local connection, reply a retry */
-										si->applet.st0 = PEER_SESSION_EXIT;
-										si->applet.st1 = PEER_SESSION_TRYAGAIN;
+										si->appctx.st0 = PEER_SESSION_EXIT;
+										si->appctx.st1 = PEER_SESSION_TRYAGAIN;
 										goto switchstate;
 									}
 									peer_session_forceshutdown(ps->session);
@@ -430,31 +430,31 @@ switchstate:
 
 				/* If table not found */
 				if (!st){
-					si->applet.st0 = PEER_SESSION_EXIT;
-					si->applet.st1 = PEER_SESSION_ERRTABLE;
+					si->appctx.st0 = PEER_SESSION_EXIT;
+					si->appctx.st1 = PEER_SESSION_ERRTABLE;
 					goto switchstate;
 				}
 
 				/* If no peer session for current peer */
 				if (!ps) {
-					si->applet.st0 = PEER_SESSION_EXIT;
-					si->applet.st1 = PEER_SESSION_ERRPEER;
+					si->appctx.st0 = PEER_SESSION_EXIT;
+					si->appctx.st1 = PEER_SESSION_ERRPEER;
 					goto switchstate;
 				}
 
-				si->applet.ctx.peers.ptr = ps;
-				si->applet.st0 = PEER_SESSION_SENDSUCCESS;
+				si->appctx.ctx.peers.ptr = ps;
+				si->appctx.st0 = PEER_SESSION_SENDSUCCESS;
 				/* fall through */
 			}
 			case PEER_SESSION_SENDSUCCESS:{
-				struct peer_session *ps = (struct peer_session *)si->applet.ctx.peers.ptr;
+				struct peer_session *ps = (struct peer_session *)si->appctx.ctx.peers.ptr;
 
 				repl = snprintf(trash.str, trash.size, "%d\n", PEER_SESSION_SUCCESSCODE);
 				repl = bi_putblk(si->ib, trash.str, repl);
 				if (repl <= 0) {
 					if (repl == -1)
 						goto out;
-					si->applet.st0 = PEER_SESSION_END;
+					si->appctx.st0 = PEER_SESSION_END;
 					goto switchstate;
 				}
 
@@ -493,11 +493,11 @@ switchstate:
 					ps->table->flags |= SHTABLE_F_RESYNC_ASSIGN;
 				}
 				/* switch to waiting message state */
-				si->applet.st0 = PEER_SESSION_WAITMSG;
+				si->appctx.st0 = PEER_SESSION_WAITMSG;
 				goto switchstate;
 			}
 			case PEER_SESSION_CONNECT: {
-				struct peer_session *ps = (struct peer_session *)si->applet.ctx.peers.ptr;
+				struct peer_session *ps = (struct peer_session *)si->appctx.ctx.peers.ptr;
 
 				/* Send headers */
 				repl = snprintf(trash.str, trash.size,
@@ -510,7 +510,7 @@ switchstate:
 				                (int)ps->table->table->key_size);
 
 				if (repl >= trash.size) {
-					si->applet.st0 = PEER_SESSION_END;
+					si->appctx.st0 = PEER_SESSION_END;
 					goto switchstate;
 				}
 
@@ -518,16 +518,16 @@ switchstate:
 				if (repl <= 0) {
 					if (repl == -1)
 						goto out;
-					si->applet.st0 = PEER_SESSION_END;
+					si->appctx.st0 = PEER_SESSION_END;
 					goto switchstate;
 				}
 
 				/* switch to the waiting statuscode state */
-				si->applet.st0 = PEER_SESSION_GETSTATUS;
+				si->appctx.st0 = PEER_SESSION_GETSTATUS;
 				/* fall through */
 			}
 			case PEER_SESSION_GETSTATUS: {
-				struct peer_session *ps = (struct peer_session *)si->applet.ctx.peers.ptr;
+				struct peer_session *ps = (struct peer_session *)si->appctx.ctx.peers.ptr;
 
 				if (si->ib->flags & CF_WRITE_PARTIAL)
 					ps->statuscode = PEER_SESSION_CONNECTEDCODE;
@@ -536,12 +536,12 @@ switchstate:
 				if (reql <= 0) { /* closed or EOL not found */
 					if (reql == 0)
 						goto out;
-					si->applet.st0 = PEER_SESSION_END;
+					si->appctx.st0 = PEER_SESSION_END;
 					goto switchstate;
 				}
 				if (trash.str[reql-1] != '\n') {
 					/* Incomplete line, we quit */
-					si->applet.st0 = PEER_SESSION_END;
+					si->appctx.st0 = PEER_SESSION_END;
 					goto switchstate;
 				}
 				else if (reql > 1 && (trash.str[reql-2] == '\r'))
@@ -591,14 +591,14 @@ switchstate:
 				}
 				else {
 					/* Status code is not success, abort */
-					si->applet.st0 = PEER_SESSION_END;
+					si->appctx.st0 = PEER_SESSION_END;
 					goto switchstate;
 				}
-				si->applet.st0 = PEER_SESSION_WAITMSG;
+				si->appctx.st0 = PEER_SESSION_WAITMSG;
 				/* fall through */
 			}
 			case PEER_SESSION_WAITMSG: {
-				struct peer_session *ps = (struct peer_session *)si->applet.ctx.peers.ptr;
+				struct peer_session *ps = (struct peer_session *)si->appctx.ctx.peers.ptr;
 				struct stksess *ts, *newts = NULL;
 				char c;
 				int totl = 0;
@@ -771,7 +771,7 @@ switchstate:
 					if (stopping) {
 						/* Close session, push resync no more needed */
 						ps->flags |= PEER_F_TEACH_COMPLETE;
-						si->applet.st0 = PEER_SESSION_END;
+						si->appctx.st0 = PEER_SESSION_END;
 						goto switchstate;
 					}
 
@@ -813,7 +813,7 @@ switchstate:
 				}
 				else {
 					/* Unknown message */
-					si->applet.st0 = PEER_SESSION_END;
+					si->appctx.st0 = PEER_SESSION_END;
 					goto switchstate;
 				}
 
@@ -834,7 +834,7 @@ incomplete:
 
 				if (reql < 0) {
 					/* there was an error */
-					si->applet.st0 = PEER_SESSION_END;
+					si->appctx.st0 = PEER_SESSION_END;
 					goto switchstate;
 				}
 
@@ -848,7 +848,7 @@ incomplete:
 						/* no more write possible */
 						if (repl == -1)
 							goto out;
-						si->applet.st0 = PEER_SESSION_END;
+						si->appctx.st0 = PEER_SESSION_END;
 						goto switchstate;
 					}
 					ps->confirm--;
@@ -865,7 +865,7 @@ incomplete:
 						/* no more write possible */
 						if (repl == -1)
 							goto out;
-						si->applet.st0 = PEER_SESSION_END;
+						si->appctx.st0 = PEER_SESSION_END;
 						goto switchstate;
 					}
 					ps->table->flags |= SHTABLE_F_RESYNC_PROCESS;
@@ -884,7 +884,7 @@ incomplete:
 						/* no more write possible */
 						if (repl == -1)
 							goto out;
-						si->applet.st0 = PEER_SESSION_END;
+						si->appctx.st0 = PEER_SESSION_END;
 						goto switchstate;
 					}
 					ps->lastack = ps->pushack;
@@ -920,7 +920,7 @@ incomplete:
 									/* no more write possible */
 									if (repl == -1)
 										goto out;
-									si->applet.st0 = PEER_SESSION_END;
+									si->appctx.st0 = PEER_SESSION_END;
 									goto switchstate;
 								}
 								ps->lastpush = ps->pushed = ts->upd.key;
@@ -954,7 +954,7 @@ incomplete:
 									/* no more write possible */
 									if (repl == -1)
 										goto out;
-									si->applet.st0 = PEER_SESSION_END;
+									si->appctx.st0 = PEER_SESSION_END;
 									goto switchstate;
 								}
 								ps->lastpush = ps->pushed = ts->upd.key;
@@ -970,7 +970,7 @@ incomplete:
 							/* no more write possible */
 							if (repl == -1)
 								goto out;
-							si->applet.st0 = PEER_SESSION_END;
+							si->appctx.st0 = PEER_SESSION_END;
 							goto switchstate;
 						}
 
@@ -1012,7 +1012,7 @@ incomplete:
 								/* no more write possible */
 								if (repl == -1)
 									goto out;
-								si->applet.st0 = PEER_SESSION_END;
+								si->appctx.st0 = PEER_SESSION_END;
 								goto switchstate;
 							}
 							ps->lastpush = ps->pushed = ts->upd.key;
@@ -1024,11 +1024,11 @@ incomplete:
 				goto out;
 			}
 			case PEER_SESSION_EXIT:
-				repl = snprintf(trash.str, trash.size, "%d\n", si->applet.st1);
+				repl = snprintf(trash.str, trash.size, "%d\n", si->appctx.st1);
 
 				if (bi_putblk(si->ib, trash.str, repl) == -1)
 					goto out;
-				si->applet.st0 = PEER_SESSION_END;
+				si->appctx.st0 = PEER_SESSION_END;
 				/* fall through */
 			case PEER_SESSION_END: {
 				si_shutw(si);
@@ -1071,8 +1071,8 @@ static void peer_session_forceshutdown(struct session * session)
 
 	/* call release to reinit resync states if needed */
 	peer_session_release(oldsi);
-	oldsi->applet.st0 = PEER_SESSION_END;
-	oldsi->applet.ctx.peers.ptr = NULL;
+	oldsi->appctx.st0 = PEER_SESSION_END;
+	oldsi->appctx.ctx.peers.ptr = NULL;
 	task_wakeup(session->task, TASK_WOKEN_MSG);
 }
 
@@ -1087,8 +1087,8 @@ int peer_accept(struct session *s)
 	 /* we have a dedicated I/O handler for the stats */
 	stream_int_register_handler(&s->si[1], &peer_applet);
 	s->target = s->si[1].conn->target; // for logging only
-	s->si[1].applet.ctx.peers.ptr = s;
-	s->si[1].applet.st0 = PEER_SESSION_ACCEPT;
+	s->si[1].appctx.ctx.peers.ptr = s;
+	s->si[1].appctx.st0 = PEER_SESSION_ACCEPT;
 
 	tv_zero(&s->logs.tv_request);
 	s->logs.t_queue = 0;
@@ -1178,8 +1178,8 @@ static struct session *peer_session_create(struct peer *peer, struct peer_sessio
 		s->si[0].flags |= SI_FL_INDEP_STR;
 
 	stream_int_register_handler(&s->si[0], &peer_applet);
-	s->si[0].applet.st0 = PEER_SESSION_CONNECT;
-	s->si[0].applet.ctx.peers.ptr = (void *)ps;
+	s->si[0].appctx.st0 = PEER_SESSION_CONNECT;
+	s->si[0].appctx.ctx.peers.ptr = (void *)ps;
 
 	s->si[1].conn->obj_type = OBJ_TYPE_CONN;
 	s->si[1].conn->t.sock.fd = -1; /* just to help with debugging */
diff --git a/src/proto_http.c b/src/proto_http.c
index dc3c9a9..94cf352 100644
--- a/src/proto_http.c
+++ b/src/proto_http.c
@@ -2806,16 +2806,16 @@ int http_handle_stats(struct session *s, struct channel *req)
 	struct uri_auth *uri_auth = s->be->uri_auth;
 	const char *uri, *h, *lookup;
 
-	memset(&si->applet.ctx.stats, 0, sizeof(si->applet.ctx.stats));
-	si->applet.ctx.stats.st_code = STAT_STATUS_INIT;
-	si->applet.ctx.stats.flags |= STAT_FMT_HTML; /* assume HTML mode by default */
+	memset(&si->appctx.ctx.stats, 0, sizeof(si->appctx.ctx.stats));
+	si->appctx.ctx.stats.st_code = STAT_STATUS_INIT;
+	si->appctx.ctx.stats.flags |= STAT_FMT_HTML; /* assume HTML mode by default */
 
 	uri = msg->chn->buf->p + msg->sl.rq.u;
 	lookup = uri + uri_auth->uri_len;
 
 	for (h = lookup; h <= uri + msg->sl.rq.u_l - 3; h++) {
 		if (memcmp(h, ";up", 3) == 0) {
-			si->applet.ctx.stats.flags |= STAT_HIDE_DOWN;
+			si->appctx.ctx.stats.flags |= STAT_HIDE_DOWN;
 			break;
 		}
 	}
@@ -2823,7 +2823,7 @@ int http_handle_stats(struct session *s, struct channel *req)
 	if (uri_auth->refresh) {
 		for (h = lookup; h <= uri + msg->sl.rq.u_l - 10; h++) {
 			if (memcmp(h, ";norefresh", 10) == 0) {
-				si->applet.ctx.stats.flags |= STAT_NO_REFRESH;
+				si->appctx.ctx.stats.flags |= STAT_NO_REFRESH;
 				break;
 			}
 		}
@@ -2831,7 +2831,7 @@ int http_handle_stats(struct session *s, struct channel *req)
 
 	for (h = lookup; h <= uri + msg->sl.rq.u_l - 4; h++) {
 		if (memcmp(h, ";csv", 4) == 0) {
-			si->applet.ctx.stats.flags &= ~STAT_FMT_HTML;
+			si->appctx.ctx.stats.flags &= ~STAT_FMT_HTML;
 			break;
 		}
 	}
@@ -2840,10 +2840,10 @@ int http_handle_stats(struct session *s, struct channel *req)
 		if (memcmp(h, ";st=", 4) == 0) {
 			int i;
 			h += 4;
-			si->applet.ctx.stats.st_code = STAT_STATUS_UNKN;
+			si->appctx.ctx.stats.st_code = STAT_STATUS_UNKN;
 			for (i = STAT_STATUS_INIT + 1; i < STAT_STATUS_SIZE; i++) {
 				if (strncmp(stat_status_codes[i], h, 4) == 0) {
-					si->applet.ctx.stats.st_code = i;
+					si->appctx.ctx.stats.st_code = i;
 					break;
 				}
 			}
@@ -2851,8 +2851,8 @@ int http_handle_stats(struct session *s, struct channel *req)
 		}
 	}
 
-	si->applet.ctx.stats.scope_str = 0;
-	si->applet.ctx.stats.scope_len = 0;
+	si->appctx.ctx.stats.scope_str = 0;
+	si->appctx.ctx.stats.scope_len = 0;
 	for (h = lookup; h <= uri + msg->sl.rq.u_l - 8; h++) {
 		if (memcmp(h, STAT_SCOPE_INPUT_NAME "=", strlen(STAT_SCOPE_INPUT_NAME) + 1) == 0) {
 			int itx = 0;
@@ -2862,7 +2862,7 @@ int http_handle_stats(struct session *s, struct channel *req)
 
 			h += strlen(STAT_SCOPE_INPUT_NAME) + 1;
 			h2 = h;
-			si->applet.ctx.stats.scope_str = h2 - msg->chn->buf->p;
+			si->appctx.ctx.stats.scope_str = h2 - msg->chn->buf->p;
 			while (*h != ';' && *h != '\0' && *h != '&' && *h != ' ' && *h != '\n') {
 				itx++;
 				h++;
@@ -2870,16 +2870,16 @@ int http_handle_stats(struct session *s, struct channel *req)
 
 			if (itx > STAT_SCOPE_TXT_MAXLEN)
 				itx = STAT_SCOPE_TXT_MAXLEN;
-			si->applet.ctx.stats.scope_len = itx;
+			si->appctx.ctx.stats.scope_len = itx;
 
-			/* scope_txt = search query, si->applet.ctx.stats.scope_len is always <= STAT_SCOPE_TXT_MAXLEN */
+			/* scope_txt = search query, si->appctx.ctx.stats.scope_len is always <= STAT_SCOPE_TXT_MAXLEN */
 			memcpy(scope_txt, h2, itx);
 			scope_txt[itx] = '\0';
 			err = invalid_char(scope_txt);
 			if (err) {
 				/* bad char in search text => clear scope */
-				si->applet.ctx.stats.scope_str = 0;
-				si->applet.ctx.stats.scope_len = 0;
+				si->appctx.ctx.stats.scope_str = 0;
+				si->appctx.ctx.stats.scope_len = 0;
 			}
 			break;
 		}
@@ -2898,14 +2898,14 @@ int http_handle_stats(struct session *s, struct channel *req)
 
 		if (ret) {
 			/* no rule, or the rule matches */
-			s->rep->prod->applet.ctx.stats.flags |= STAT_ADMIN;
+			s->rep->prod->appctx.ctx.stats.flags |= STAT_ADMIN;
 			break;
 		}
 	}
 
 	/* Was the status page requested with a POST ? */
 	if (unlikely(txn->meth == HTTP_METH_POST && txn->req.body_len > 0)) {
-		if (si->applet.ctx.stats.flags & STAT_ADMIN) {
+		if (si->appctx.ctx.stats.flags & STAT_ADMIN) {
 			if (msg->msg_state < HTTP_MSG_100_SENT) {
 				/* If we have HTTP/1.1 and Expect: 100-continue, then we must
 				 * send an HTTP/1.1 100 Continue intermediate response.
@@ -2922,21 +2922,21 @@ int http_handle_stats(struct session *s, struct channel *req)
 				msg->msg_state = HTTP_MSG_100_SENT;
 				s->logs.tv_request = now;  /* update the request timer to reflect full request */
 			}
-			s->rep->prod->applet.st0 = STAT_HTTP_POST;
+			s->rep->prod->appctx.st0 = STAT_HTTP_POST;
 		}
 		else {
-			si->applet.ctx.stats.st_code = STAT_STATUS_DENY;
-			s->rep->prod->applet.st0 = STAT_HTTP_LAST;
+			si->appctx.ctx.stats.st_code = STAT_STATUS_DENY;
+			s->rep->prod->appctx.st0 = STAT_HTTP_LAST;
 		}
 	}
 	else {
 		/* So it was another method (GET/HEAD) */
-		s->rep->prod->applet.st0 = STAT_HTTP_HEAD;
+		s->rep->prod->appctx.st0 = STAT_HTTP_HEAD;
 	}
 
 	s->task->nice = -32; /* small boost for HTTP statistics */
 	stream_int_register_handler(s->rep->prod, &http_stats_applet);
-	s->rep->prod->applet.st1 = s->rep->prod->applet.st2 = 0;
+	s->rep->prod->appctx.st1 = s->rep->prod->appctx.st2 = 0;
 	return 1;
 }
 
-- 
1.8.1.5

