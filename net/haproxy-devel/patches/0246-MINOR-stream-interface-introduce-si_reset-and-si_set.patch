From 3ed35ef05bdc773886705bd3b65867441abde4dc Mon Sep 17 00:00:00 2001
From: Willy Tarreau <w@1wt.eu>
Date: Thu, 24 Oct 2013 11:51:38 +0200
Subject: [PATCH 246/277] MINOR: stream-interface: introduce si_reset() and
 si_set_state()

The first function is used to (re)initialize a stream interface and
the second to force it into a known state. These are intended for
cleaning up the stream interface initialization code in session.c
and peers.c and avoiding future issues with missing initializations.
---
 include/proto/stream_interface.h | 24 ++++++++++++++++++++++++
 src/peers.c                      | 20 ++++++++------------
 src/session.c                    | 26 +++++++-------------------
 3 files changed, 39 insertions(+), 31 deletions(-)

diff --git a/include/proto/stream_interface.h b/include/proto/stream_interface.h
index 1439a03..8fc3281 100644
--- a/include/proto/stream_interface.h
+++ b/include/proto/stream_interface.h
@@ -46,6 +46,30 @@ struct task *stream_int_register_handler(struct stream_interface *si,
 					 struct si_applet *app);
 void stream_int_unregister_handler(struct stream_interface *si);
 
+/* initializes a stream interface in the SI_ST_INI state. It's detached from
+ * any endpoint and is only attached to an owner (generally a task).
+ */
+static inline void si_reset(struct stream_interface *si, void *owner)
+{
+	si->owner          = owner;
+	si->err_type       = SI_ET_NONE;
+	si->conn_retries   = 0;  /* used for logging too */
+	si->send_proxy_ofs = 0;
+	si->exp            = TICK_ETERNITY;
+	si->flags          = SI_FL_NONE;
+	si->end            = NULL;
+	si->state          = si->prev_state = SI_ST_INI;
+}
+
+/* sets the current and previous state of a stream interface to <state>. This
+ * is mainly used to create one in the established state on incoming
+ * conncetions.
+ */
+static inline void si_set_state(struct stream_interface *si, int state)
+{
+	si->state = si->prev_state = state;
+}
+
 static inline void si_prepare_none(struct stream_interface *si)
 {
 	si->ops = &si_embedded_ops;
diff --git a/src/peers.c b/src/peers.c
index f3754cb..8623704 100644
--- a/src/peers.c
+++ b/src/peers.c
@@ -1164,12 +1164,9 @@ static struct session *peer_session_create(struct peer *peer, struct peer_sessio
 	s->req = s->rep = NULL; /* will be allocated later */
 
 	s->si[0].conn = NULL;
-	s->si[0].owner = t;
-	s->si[0].state = s->si[0].prev_state = SI_ST_EST;
-	s->si[0].err_type = SI_ET_NONE;
-	s->si[0].send_proxy_ofs = 0;
-	s->si[0].exp = TICK_ETERNITY;
-	s->si[0].flags = SI_FL_NONE;
+	si_reset(&s->si[0], t);
+	si_set_state(&s->si[0], SI_ST_EST);
+
 	if (s->fe->options2 & PR_O2_INDEPSTR)
 		s->si[0].flags |= SI_FL_INDEP_STR;
 
@@ -1177,13 +1174,12 @@ static struct session *peer_session_create(struct peer *peer, struct peer_sessio
 	s->si[0].appctx.st0 = PEER_SESSION_CONNECT;
 	s->si[0].appctx.ctx.peers.ptr = (void *)ps;
 
-	s->si[1].owner = t;
-	s->si[1].state = s->si[1].prev_state = SI_ST_ASS;
+	si_reset(&s->si[1], t);
+
+	/* initiate an outgoing connection */
+	si_set_state(&s->si[1], SI_ST_ASS);
 	s->si[1].conn_retries = p->conn_retries;
-	s->si[1].err_type = SI_ET_NONE;
-	s->si[1].send_proxy_ofs = 0;
-	s->si[1].exp = TICK_ETERNITY;
-	s->si[1].flags = SI_FL_NONE;
+
 	if (s->be->options2 & PR_O2_INDEPSTR)
 		s->si[1].flags |= SI_FL_INDEP_STR;
 
diff --git a/src/session.c b/src/session.c
index 88ed5ab..df1b43c 100644
--- a/src/session.c
+++ b/src/session.c
@@ -426,6 +426,12 @@ int session_complete(struct session *s)
 	LIST_INIT(&s->back_refs);
 
 	/* attach the incoming connection to the stream interface now */
+	si_reset(&s->si[0], t);
+	si_set_state(&s->si[0], SI_ST_EST);
+
+	if (likely(s->fe->options2 & PR_O2_INDEPSTR))
+		s->si[0].flags |= SI_FL_INDEP_STR;
+
 	s->si[0].conn = conn;
 	si_prepare_conn(&s->si[0], l->proto, l->xprt);
 
@@ -463,28 +469,10 @@ int session_complete(struct session *s)
 					       s->stkctr[i].table->data_arg[STKTABLE_DT_SESS_RATE].u, 1);
 	}
 
-	/* this part should be common with other protocols */
-	s->si[0].owner     = t;
-	s->si[0].state     = s->si[0].prev_state = SI_ST_EST;
-	s->si[0].err_type  = SI_ET_NONE;
-	s->si[0].send_proxy_ofs = 0;
-	s->si[0].exp       = TICK_ETERNITY;
-	s->si[0].flags     = SI_FL_NONE;
-
-	if (likely(s->fe->options2 & PR_O2_INDEPSTR))
-		s->si[0].flags |= SI_FL_INDEP_STR;
-
 	/* pre-initialize the other side's stream interface to an INIT state. The
 	 * callbacks will be initialized before attempting to connect.
 	 */
-	s->si[1].owner     = t;
-	s->si[1].state     = s->si[1].prev_state = SI_ST_INI;
-	s->si[1].err_type  = SI_ET_NONE;
-	s->si[1].conn_retries = 0;  /* used for logging too */
-	s->si[1].send_proxy_ofs = 0;
-	s->si[1].exp       = TICK_ETERNITY;
-	s->si[1].flags     = SI_FL_NONE;
-
+	si_reset(&s->si[1], t);
 	conn_init(s->si[1].conn);
 	s->si[1].conn->target = NULL;
 	si_prepare_none(&s->si[1]);
-- 
1.8.1.5

