From cc0e0b3dbbb09906daee933b845d120e46ae1747 Mon Sep 17 00:00:00 2001
From: Thierry FOURNIER <tfournier@exceliance.fr>
Date: Fri, 6 Dec 2013 16:56:40 +0100
Subject: [PATCH 289/311] MINOR: pattern: Each pattern sets the expected input
 type

This is used later for increasing the compability with incoming
sample types. When multiple compatible types are supported, one
is arbitrarily used (eg: UINT).
---
 include/proto/pattern.h |  3 +++
 include/types/pattern.h |  1 +
 src/pattern.c           | 17 ++++++++++++++++-
 src/proto_http.c        |  3 +++
 4 files changed, 23 insertions(+), 1 deletion(-)

diff --git a/include/proto/pattern.h b/include/proto/pattern.h
index 29773f8..91bb335 100644
--- a/include/proto/pattern.h
+++ b/include/proto/pattern.h
@@ -86,6 +86,9 @@ enum pat_match_res pat_match_int(struct sample *smp, struct pattern *pattern);
 /* Parse an integer. It is put both in min and max. */
 int pat_parse_int(const char **text, struct pattern *pattern, struct sample_storage *smp, int *opaque, char **err);
 
+/* Parse len like an integer, but specify expected string type */
+int pat_parse_len(const char **text, struct pattern *pattern, struct sample_storage *smp, int *opaque, char **err);
+
 /* Parse an version. It is put both in min and max. */
 int pat_parse_dotted_ver(const char **text, struct pattern *pattern, struct sample_storage *smp, int *opaque, char **err);
 
diff --git a/include/types/pattern.h b/include/types/pattern.h
index 3f0a085..7a00e8b 100644
--- a/include/types/pattern.h
+++ b/include/types/pattern.h
@@ -113,6 +113,7 @@ struct pat_idx_elt {
 struct pattern {
 	struct list list;                       /* chaining */
 	int type;                               /* type of the ACL pattern (SMP_T_*) */
+	int expect_type;                        /* type of the expected sample (SMP_T_*) */
 	union {
 		int i;                          /* integer value */
 		struct {
diff --git a/src/pattern.c b/src/pattern.c
index aef2a00..3f25607 100644
--- a/src/pattern.c
+++ b/src/pattern.c
@@ -45,7 +45,7 @@ int (*pat_parse_fcts[PAT_MATCH_NUM])(const char **, struct pattern *, struct sam
 	[PAT_MATCH_INT]   = pat_parse_int,
 	[PAT_MATCH_IP]    = pat_parse_ip,
 	[PAT_MATCH_BIN]   = pat_parse_bin,
-	[PAT_MATCH_LEN]   = pat_parse_int,
+	[PAT_MATCH_LEN]   = pat_parse_len,
 	[PAT_MATCH_STR]   = pat_parse_str,
 	[PAT_MATCH_BEG]   = pat_parse_str,
 	[PAT_MATCH_SUB]   = pat_parse_str,
@@ -407,6 +407,7 @@ int pat_parse_str(const char **text, struct pattern *pattern, struct sample_stor
 
 	len  = strlen(*text);
 	pattern->type = SMP_T_CSTR;
+	pattern->expect_type = SMP_T_CSTR;
 
 	if (pattern->flags & PAT_F_TREE_OK) {
 		/* we're allowed to put the data in a tree whose root is pointed
@@ -441,6 +442,7 @@ int pat_parse_str(const char **text, struct pattern *pattern, struct sample_stor
 int pat_parse_bin(const char **text, struct pattern *pattern, struct sample_storage *smp, int *opaque, char **err)
 {
 	pattern->type = SMP_T_CBIN;
+	pattern->expect_type = SMP_T_CBIN;
 	pattern->smp = smp;
 
 	return parse_binary(*text, &pattern->ptr.str, &pattern->len, err);
@@ -499,6 +501,7 @@ int pat_parse_reg(const char **text, struct pattern *pattern, struct sample_stor
 	pattern->ptr.reg = preg;
 	pattern->freeptrbuf = &pat_free_reg;
 	pattern->smp = smp;
+	pattern->expect_type = SMP_T_CSTR;
 	return 1;
 }
 
@@ -523,6 +526,7 @@ int pat_parse_int(const char **text, struct pattern *pattern, struct sample_stor
 	const char *ptr = *text;
 
 	pattern->type = SMP_T_UINT;
+	pattern->expect_type = SMP_T_UINT;
 	pattern->smp = smp;
 	while (!isdigit((unsigned char)*ptr)) {
 		switch (get_std_op(ptr)) {
@@ -588,6 +592,15 @@ int pat_parse_int(const char **text, struct pattern *pattern, struct sample_stor
 	return skip + 1;
 }
 
+int pat_parse_len(const char **text, struct pattern *pattern, struct sample_storage *smp, int *opaque, char **err)
+{
+	int ret;
+
+	ret = pat_parse_int(text, pattern, smp, opaque, err);
+	pattern->expect_type = SMP_T_CSTR;
+	return ret;
+}
+
 /* Parse a range of positive 2-component versions delimited by either ':' or
  * '-'. The version consists in a major and a minor, both of which must be
  * smaller than 65536, because internally they will be represented as a 32-bit
@@ -668,6 +681,7 @@ int pat_parse_dotted_ver(const char **text, struct pattern *pattern, struct samp
 	}
 
 	pattern->smp = smp;
+	pattern->expect_type = SMP_T_CSTR;
 
 	if (!last)
 		pattern->val.range.min = i;
@@ -705,6 +719,7 @@ int pat_parse_ip(const char **text, struct pattern *pattern, struct sample_stora
 	if (pattern->flags & PAT_F_TREE_OK)
 		tree = pattern->val.tree;
 
+	pattern->expect_type = SMP_T_ADDR;
 	if (str2net(*text, &pattern->val.ipv4.addr, &pattern->val.ipv4.mask)) {
 		unsigned int mask = ntohl(pattern->val.ipv4.mask.s_addr);
 		struct pat_idx_elt *node;
diff --git a/src/proto_http.c b/src/proto_http.c
index 900f747..41561c5 100644
--- a/src/proto_http.c
+++ b/src/proto_http.c
@@ -8746,12 +8746,15 @@ static int pat_parse_meth(const char **text, struct pattern *pattern, struct sam
 	pattern->val.i = meth;
 	if (meth == HTTP_METH_OTHER) {
 		pattern->ptr.str = strdup(*text);
+		pattern->expect_type = SMP_T_CSTR;
 		if (!pattern->ptr.str) {
 			memprintf(err, "out of memory while loading pattern");
 			return 0;
 		}
 		pattern->len = len;
 	}
+	else
+		pattern->expect_type = SMP_T_UINT;
 	return 1;
 }
 
-- 
1.8.1.5

