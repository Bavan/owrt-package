From 0161d62d23d227dd6bd50914bae3103f098fd7ea Mon Sep 17 00:00:00 2001
From: Willy Tarreau <w@1wt.eu>
Date: Tue, 2 Apr 2013 01:26:55 +0200
Subject: [PATCH 100/105] OPTIM: http: improve branching in chunk size parser

By tweaking a bit some conditions in http_parse_chunk_size(), we could
improve the overall performance in the worst case by 15%.
---
 include/common/standard.h |  6 +++---
 src/proto_http.c          | 12 ++++++------
 2 files changed, 9 insertions(+), 9 deletions(-)

diff --git a/include/common/standard.h b/include/common/standard.h
index 8e88ee5..4de4f73 100644
--- a/include/common/standard.h
+++ b/include/common/standard.h
@@ -187,9 +187,9 @@ extern int ishex(char s);
  */
 static inline int hex2i(int c)
 {
-	if ((unsigned char)(c -= '0') > 9) {
-		if ((unsigned char)(c -= 'A' - '0') > 5 &&
-		    (unsigned char)(c -= 'a' - 'A') > 5)
+	if (unlikely((unsigned char)(c -= '0') > 9)) {
+		if (likely((unsigned char)(c -= 'A' - '0') > 5 &&
+			      (unsigned char)(c -= 'a' - 'A') > 5))
 			c = -11;
 		c += 10;
 	}
diff --git a/src/proto_http.c b/src/proto_http.c
index b85c6aa..7abfe31 100644
--- a/src/proto_http.c
+++ b/src/proto_http.c
@@ -1776,7 +1776,7 @@ static inline int http_parse_chunk_size(struct http_msg *msg)
 		c = hex2i(*ptr);
 		if (c < 0) /* not a hex digit anymore */
 			break;
-		if (++ptr >= end)
+		if (unlikely(++ptr >= end))
 			ptr = buf->data;
 		if (chunk & 0xF8000000) /* integer overflow will occur if result >= 2GB */
 			goto error;
@@ -1784,13 +1784,13 @@ static inline int http_parse_chunk_size(struct http_msg *msg)
 	}
 
 	/* empty size not allowed */
-	if (ptr == ptr_old)
+	if (unlikely(ptr == ptr_old))
 		goto error;
 
 	while (http_is_spht[(unsigned char)*ptr]) {
 		if (++ptr >= end)
 			ptr = buf->data;
-		if (ptr == stop)
+		if (unlikely(ptr == stop))
 			return 0;
 	}
 
@@ -1838,7 +1838,7 @@ static inline int http_parse_chunk_size(struct http_msg *msg)
 	 * which may or may not be present. We save that into ->next and
 	 * ->sov.
 	 */
-	if (ptr < ptr_old)
+	if (unlikely(ptr < ptr_old))
 		msg->sov += buf->size;
 	msg->sov += ptr - ptr_old;
 	msg->next = buffer_count(buf, buf->p, ptr);
@@ -1968,7 +1968,7 @@ static inline int http_skip_chunk_crlf(struct http_msg *msg)
 	}
 
 	ptr++;
-	if (ptr >= buf->data + buf->size)
+	if (unlikely(ptr >= buf->data + buf->size))
 		ptr = buf->data;
 	/* prepare the CRLF to be forwarded (between ->sol and ->sov) */
 	msg->sol = 0;
@@ -5895,7 +5895,7 @@ int http_response_forward_body(struct session *s, struct channel *res, int an_bi
 					}
 				}
 			}
-		/* otherwise we're in HTTP_MSG_DATA or HTTP_MSG_TRAILERS state */
+			/* otherwise we're in HTTP_MSG_DATA or HTTP_MSG_TRAILERS state */
 		}
 		else if (msg->msg_state == HTTP_MSG_CHUNK_CRLF) {
 			/* we want the CRLF after the data */
-- 
1.8.1.5

