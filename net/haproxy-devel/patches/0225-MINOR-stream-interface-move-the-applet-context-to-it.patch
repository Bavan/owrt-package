From 452d3bb0c4378620f178690b0d6e39fe8e1dab7a Mon Sep 17 00:00:00 2001
From: Willy Tarreau <w@1wt.eu>
Date: Sun, 24 Nov 2013 02:28:49 +0100
Subject: [PATCH 225/277] MINOR: stream-interface: move the applet context to
 its own struct

In preparation of making the applet context dynamically allocatable,
we create a "struct appctx". Nothing else was changed, it's the same
struct as the one which was in the stream interface.
---
 include/types/stream_interface.h | 99 +++++++++++++++++++++-------------------
 1 file changed, 51 insertions(+), 48 deletions(-)

diff --git a/include/types/stream_interface.h b/include/types/stream_interface.h
index 84fec07..1c986ba 100644
--- a/include/types/stream_interface.h
+++ b/include/types/stream_interface.h
@@ -89,6 +89,56 @@ struct si_ops {
 	void (*shutw)(struct stream_interface *);   /* shut write function */
 };
 
+/* Context of a running applet. */
+struct appctx {
+	unsigned int st0;          /* CLI state for stats, session state for peers */
+	unsigned int st1;          /* prompt for stats, session error for peers */
+	unsigned int st2;          /* output state for stats, unused by peers  */
+
+	union {
+		struct {
+			struct proxy *px;
+			struct server *sv;
+			void *l;
+			int scope_str;		/* limit scope to a frontend/backend substring */
+			int scope_len;		/* length of the string above in the buffer */
+			int px_st;		/* STAT_PX_ST* */
+			unsigned int flags;	/* STAT_* */
+			int iid, type, sid;	/* proxy id, type and service id if bounding of stats is enabled */
+			int st_code;		/* the status code returned by an action */
+		} stats;
+		struct {
+			struct bref bref;	/* back-reference from the session being dumped */
+			void *target;		/* session we want to dump, or NULL for all */
+			unsigned int uid;	/* if non-null, the uniq_id of the session being dumped */
+			int section;		/* section of the session being dumped */
+			int pos;		/* last position of the current session's buffer */
+		} sess;
+		struct {
+			int iid;		/* if >= 0, ID of the proxy to filter on */
+			struct proxy *px;	/* current proxy being dumped, NULL = not started yet. */
+			unsigned int buf;	/* buffer being dumped, 0 = req, 1 = rep */
+			unsigned int sid;	/* session ID of error being dumped */
+			int ptr;		/* <0: headers, >=0 : text pointer to restart from */
+			int bol;		/* pointer to beginning of current line */
+		} errors;
+		struct {
+			void *target;		/* table we want to dump, or NULL for all */
+			struct proxy *proxy;	/* table being currently dumped (first if NULL) */
+			struct stksess *entry;	/* last entry we were trying to dump (or first if NULL) */
+			long long value;	/* value to compare against */
+			signed char data_type;	/* type of data to compare, or -1 if none */
+			signed char data_op;	/* operator (STD_OP_*) when data_type set */
+		} table;
+		struct {
+			const char *msg;	/* pointer to a persistent message to be returned in PRINT state */
+		} cli;
+		struct {
+			void *ptr;              /* multi-purpose pointer for peers */
+		} peers;
+	} ctx;					/* used by stats I/O handlers to dump the stats */
+};
+
 /* A stream interface has 3 parts :
  *  - the buffer side, which interfaces to the buffers.
  *  - the remote side, which describes the state and address of the other side.
@@ -118,54 +168,7 @@ struct stream_interface {
 	/* struct members below are the "remote" part, as seen from the buffer side */
 	int conn_retries;	/* number of connect retries left */
 	int send_proxy_ofs;	/* <0 = offset to (re)send from the end, >0 = send all */
-	struct {
-		unsigned int st0;     /* CLI state for stats, session state for peers */
-		unsigned int st1;     /* prompt for stats, session error for peers */
-		unsigned int st2;     /* output state for stats, unused by peers  */
-
-		union {
-			struct {
-				struct proxy *px;
-				struct server *sv;
-				void *l;
-				int scope_str;		/* limit scope to a frontend/backend substring */
-				int scope_len;		/* length of the string above in the buffer */
-				int px_st;		/* STAT_PX_ST* */
-				unsigned int flags;	/* STAT_* */
-				int iid, type, sid;	/* proxy id, type and service id if bounding of stats is enabled */
-				int st_code;		/* the status code returned by an action */
-			} stats;
-			struct {
-				struct bref bref;	/* back-reference from the session being dumped */
-				void *target;		/* session we want to dump, or NULL for all */
-				unsigned int uid;	/* if non-null, the uniq_id of the session being dumped */
-				int section;		/* section of the session being dumped */
-				int pos;		/* last position of the current session's buffer */
-			} sess;
-			struct {
-				int iid;		/* if >= 0, ID of the proxy to filter on */
-				struct proxy *px;	/* current proxy being dumped, NULL = not started yet. */
-				unsigned int buf;	/* buffer being dumped, 0 = req, 1 = rep */
-				unsigned int sid;	/* session ID of error being dumped */
-				int ptr;		/* <0: headers, >=0 : text pointer to restart from */
-				int bol;		/* pointer to beginning of current line */
-			} errors;
-			struct {
-				void *target;		/* table we want to dump, or NULL for all */
-				struct proxy *proxy;	/* table being currently dumped (first if NULL) */
-				struct stksess *entry;	/* last entry we were trying to dump (or first if NULL) */
-				long long value;	/* value to compare against */
-				signed char data_type;	/* type of data to compare, or -1 if none */
-				signed char data_op;	/* operator (STD_OP_*) when data_type set */
-			} table;
-			struct {
-				const char *msg;	/* pointer to a persistent message to be returned in PRINT state */
-			} cli;
-			struct {
-				void *ptr;              /* multi-purpose pointer for peers */
-			} peers;
-		} ctx;					/* used by stats I/O handlers to dump the stats */
-	} applet;
+	struct appctx applet;   /* context of the running applet if any */
 };
 
 /* An applet designed to run in a stream interface */
-- 
1.8.1.5

