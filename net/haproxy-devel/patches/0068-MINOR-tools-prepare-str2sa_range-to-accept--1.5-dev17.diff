From d393a628bb999cd0bdfdf27dca3d921cfe2b3d28 Mon Sep 17 00:00:00 2001
From: Willy Tarreau <w@1wt.eu>
Date: Mon, 4 Mar 2013 18:22:00 +0100
Subject: MINOR: tools: prepare str2sa_range() to accept a prefix

We'll need str2sa_range() to support a prefix for unix sockets. Since
we don't always want to use it (eg: stats socket), let's not take it
unconditionally from global but let the caller pass it.
---
 include/common/standard.h |    4 +++-
 src/cfgparse.c            |   22 +++++++++++-----------
 src/standard.c            |    5 ++++-
 3 files changed, 18 insertions(+), 13 deletions(-)

diff --git a/include/common/standard.h b/include/common/standard.h
index e476b90..4bc656d 100644
--- a/include/common/standard.h
+++ b/include/common/standard.h
@@ -239,8 +239,10 @@ struct sockaddr_storage *str2ip(const char *str);
  * address wants to ignore port, it must be terminated by a trailing colon (':').
  * The IPv6 '::' address is IN6ADDR_ANY, so in order to bind to a given port on
  * IPv6, use ":::port". NULL is returned if the host part cannot be resolved.
+ * If <pfx> is non-null, it is used as a string prefix before any path-based
+ * address (typically the path to a unix socket).
  */
-struct sockaddr_storage *str2sa_range(const char *str, int *low, int *high, char **err);
+struct sockaddr_storage *str2sa_range(const char *str, int *low, int *high, char **err, const char *pfx);
 
 /* converts <str> to a struct in_addr containing a network mask. It can be
  * passed in dotted form (255.255.255.0) or in CIDR form (24). It returns 1
diff --git a/src/cfgparse.c b/src/cfgparse.c
index c6f4abf..e33ab61 100644
--- a/src/cfgparse.c
+++ b/src/cfgparse.c
@@ -239,7 +239,7 @@ int str2listener(char *str, struct proxy *curproxy, struct bind_conf *bind_conf,
 		else {
 			struct sockaddr_storage *ss2;
 
-			ss2 = str2sa_range(str, &port, &end, NULL);
+			ss2 = str2sa_range(str, &port, &end, NULL, NULL);
 			if (!ss2) {
 				memprintf(err, "invalid listening address: '%s'\n", str);
 				goto fail;
@@ -1156,7 +1156,7 @@ int cfg_parse_global(const char *file, int linenum, char **args, int kwm)
 			struct sockaddr_storage *sk;
 			int port1, port2;
 
-			sk = str2sa_range(args[1], &port1, &port2, NULL);
+			sk = str2sa_range(args[1], &port1, &port2, NULL, NULL);
 			if (!sk) {
 				Alert("parsing [%s:%d] : '%s' : unknown host in '%s'\n", file, linenum, args[0], args[1]);
 				err_code |= ERR_ALERT | ERR_FATAL;
@@ -1530,7 +1530,7 @@ int cfg_parse_peers(const char *file, int linenum, char **args, int kwm)
 		newpeer->last_change = now.tv_sec;
 		newpeer->id = strdup(args[1]);
 
-		sk = str2sa_range(args[2], &port1, &port2, NULL);
+		sk = str2sa_range(args[2], &port1, &port2, NULL, NULL);
 		if (!sk) {
 			Alert("parsing [%s:%d] : '%s %s' : unknown host in '%s'\n", file, linenum, args[0], args[1], args[2]);
 			err_code |= ERR_ALERT | ERR_FATAL;
@@ -3986,7 +3986,7 @@ stats_error_parsing:
 		else if (warnifnotcap(curproxy, PR_CAP_BE, file, linenum, args[0], NULL))
 			err_code |= ERR_WARN;
 
-		sk = str2sa_range(args[1], &port1, &port2, NULL);
+		sk = str2sa_range(args[1], &port1, &port2, NULL, NULL);
 		if (!sk) {
 			Alert("parsing [%s:%d] : '%s' : unknown host in '%s'\n", file, linenum, args[0], args[1]);
 			err_code |= ERR_ALERT | ERR_FATAL;
@@ -4102,7 +4102,7 @@ stats_error_parsing:
 			 *  - IP:+N => port=+N, relative
 			 *  - IP:-N => port=-N, relative
 			 */
-			sk = str2sa_range(args[2], &port1, &port2, NULL);
+			sk = str2sa_range(args[2], &port1, &port2, NULL, NULL);
 			if (!sk) {
 				Alert("parsing [%s:%d] : Unknown host in '%s'\n", file, linenum, args[2]);
 				err_code |= ERR_ALERT | ERR_FATAL;
@@ -4269,7 +4269,7 @@ stats_error_parsing:
 				struct sockaddr_storage *sk;
 				int port1, port2;
 
-				sk = str2sa_range(args[cur_arg + 1], &port1, &port2, NULL);
+				sk = str2sa_range(args[cur_arg + 1], &port1, &port2, NULL, NULL);
 				if (!sk) {
 					Alert("parsing [%s:%d] : '%s' : unknown host in '%s'\n",
 					      file, linenum, args[cur_arg], args[cur_arg + 1]);
@@ -4461,7 +4461,7 @@ stats_error_parsing:
 					goto out;
 				}
 				newsrv->conn_src.opts |= CO_SRC_BIND;
-				sk = str2sa_range(args[cur_arg + 1], &port_low, &port_high, NULL);
+				sk = str2sa_range(args[cur_arg + 1], &port_low, &port_high, NULL, NULL);
 				if (!sk) {
 					Alert("parsing [%s:%d] : Unknown host in '%s'\n", file, linenum, args[cur_arg + 1]);
 					err_code |= ERR_ALERT | ERR_FATAL;
@@ -4559,7 +4559,7 @@ stats_error_parsing:
 							struct sockaddr_storage *sk;
 							int port1, port2;
 
-							sk = str2sa_range(args[cur_arg + 1], &port1, &port2, NULL);
+							sk = str2sa_range(args[cur_arg + 1], &port1, &port2, NULL, NULL);
 							if (!sk) {
 								Alert("parsing [%s:%d] : '%s' : unknown host in '%s'\n",
 								      file, linenum, args[cur_arg], args[cur_arg + 1]);
@@ -4887,7 +4887,7 @@ stats_error_parsing:
 				struct sockaddr_storage *sk;
 				int port1, port2;
 
-				sk = str2sa_range(args[1], &port1, &port2, NULL);
+				sk = str2sa_range(args[1], &port1, &port2, NULL, NULL);
 				if (!sk) {
 					Alert("parsing [%s:%d] : '%s' : unknown host in '%s'\n",
 					      file, linenum, args[0], args[1]);
@@ -4937,7 +4937,7 @@ stats_error_parsing:
 		curproxy->conn_src.iface_name = NULL;
 		curproxy->conn_src.iface_len = 0;
 
-		sk = str2sa_range(args[1], &port1, &port2, NULL);
+		sk = str2sa_range(args[1], &port1, &port2, NULL, NULL);
 		if (!sk) {
 			Alert("parsing [%s:%d] : '%s' : unknown host in '%s'\n",
 			      file, linenum, args[0], args[1]);
@@ -5020,7 +5020,7 @@ stats_error_parsing:
 						goto out;
 					}
 				} else {
-					struct sockaddr_storage *sk = str2sa_range(args[cur_arg + 1], &port1, &port2, NULL);
+					struct sockaddr_storage *sk = str2sa_range(args[cur_arg + 1], &port1, &port2, NULL, NULL);
 
 					if (!sk) {
 						Alert("parsing [%s:%d] : '%s' : unknown host in '%s'\n",
diff --git a/src/standard.c b/src/standard.c
index 857d9b4..08af648 100644
--- a/src/standard.c
+++ b/src/standard.c
@@ -637,8 +637,11 @@ struct sockaddr_storage *str2ip(const char *str)
  * is mandatory after the IP address even when no port is specified. NULL is
  * returned if the address cannot be parsed. The <low> and <high> ports are
  * always initialized if non-null.
+ *
+ * If <pfx> is non-null, it is used as a string prefix before any path-based
+ * address (typically the path to a unix socket).
  */
-struct sockaddr_storage *str2sa_range(const char *str, int *low, int *high, char **err)
+struct sockaddr_storage *str2sa_range(const char *str, int *low, int *high, char **err, const char *pfx)
 {
 	struct sockaddr_storage *ret = NULL;
 	char *str2;
-- 
1.7.1

