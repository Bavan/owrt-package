From 08382955fe3f2813cb6458950d1fdd951a66c082 Mon Sep 17 00:00:00 2001
From: Willy Tarreau <w@1wt.eu>
Date: Mon, 8 Jul 2013 16:16:22 +0200
Subject: [PATCH 206/277] CLEANUP: stream_interface: remove unused field
 err_loc

This field was still fed with a pointer to the server that caught an
error but was not used anymore. Let's remove it.
---
 include/types/stream_interface.h | 1 -
 src/backend.c                    | 3 ---
 src/peers.c                      | 2 --
 src/proto_http.c                 | 2 --
 src/session.c                    | 8 --------
 5 files changed, 16 deletions(-)

diff --git a/include/types/stream_interface.h b/include/types/stream_interface.h
index 2500894..fe49371 100644
--- a/include/types/stream_interface.h
+++ b/include/types/stream_interface.h
@@ -107,7 +107,6 @@ struct stream_interface {
 	unsigned int exp;       /* wake up time for connect, queue, turn-around, ... */
 	void *owner;            /* generally a (struct task*) */
 	unsigned int err_type;  /* first error detected, one of SI_ET_* */
-	void *err_loc;          /* commonly the server, NULL when SI_ET_NONE */
 
 	struct connection *conn; /* descriptor for a connection */
 	struct si_ops *ops;     /* general operations at the stream interface layer */
diff --git a/src/backend.c b/src/backend.c
index c2e286a..b834917 100644
--- a/src/backend.c
+++ b/src/backend.c
@@ -1072,7 +1072,6 @@ int srv_redispatch_connect(struct session *t)
 
 		if (!t->req->cons->err_type) {
 			t->req->cons->err_type = SI_ET_QUEUE_ERR;
-			t->req->cons->err_loc = srv;
 		}
 
 		srv->counters.failed_conns++;
@@ -1083,7 +1082,6 @@ int srv_redispatch_connect(struct session *t)
 		/* note: it is guaranteed that srv == NULL here */
 		if (!t->req->cons->err_type) {
 			t->req->cons->err_type = SI_ET_CONN_ERR;
-			t->req->cons->err_loc = NULL;
 		}
 
 		t->be->be_counters.failed_conns++;
@@ -1099,7 +1097,6 @@ int srv_redispatch_connect(struct session *t)
 	default:
 		if (!t->req->cons->err_type) {
 			t->req->cons->err_type = SI_ET_CONN_OTHER;
-			t->req->cons->err_loc = srv;
 		}
 
 		if (srv)
diff --git a/src/peers.c b/src/peers.c
index 2c8d9cc..0ed4b85 100644
--- a/src/peers.c
+++ b/src/peers.c
@@ -1170,7 +1170,6 @@ static struct session *peer_session_create(struct peer *peer, struct peer_sessio
 	s->si[0].owner = t;
 	s->si[0].state = s->si[0].prev_state = SI_ST_EST;
 	s->si[0].err_type = SI_ET_NONE;
-	s->si[0].err_loc = NULL;
 	s->si[0].release = NULL;
 	s->si[0].send_proxy_ofs = 0;
 	s->si[0].conn->target = &l->obj_type;
@@ -1190,7 +1189,6 @@ static struct session *peer_session_create(struct peer *peer, struct peer_sessio
 	s->si[1].state = s->si[1].prev_state = SI_ST_ASS;
 	s->si[1].conn_retries = p->conn_retries;
 	s->si[1].err_type = SI_ET_NONE;
-	s->si[1].err_loc = NULL;
 	s->si[1].release = NULL;
 	s->si[1].send_proxy_ofs = 0;
 	s->si[1].conn->target = &s->be->obj_type;
diff --git a/src/proto_http.c b/src/proto_http.c
index 51a43a4..acef371 100644
--- a/src/proto_http.c
+++ b/src/proto_http.c
@@ -896,7 +896,6 @@ void http_perform_server_redirect(struct session *s, struct stream_interface *si
 	si_shutr(si);
 	si_shutw(si);
 	si->err_type = SI_ET_NONE;
-	si->err_loc  = NULL;
 	si->state    = SI_ST_CLO;
 
 	/* send the message */
@@ -4481,7 +4480,6 @@ void http_end_txn_clean_session(struct session *s)
 	s->req->cons->conn->err_code = CO_ER_NONE;
 	s->req->cons->err_type  = SI_ET_NONE;
 	s->req->cons->conn_retries = 0;  /* used for logging too */
-	s->req->cons->err_loc   = NULL;
 	s->req->cons->exp       = TICK_ETERNITY;
 	s->req->cons->flags     = SI_FL_NONE;
 	s->req->flags &= ~(CF_SHUTW|CF_SHUTW_NOW|CF_AUTO_CONNECT|CF_WRITE_ERROR|CF_STREAMER|CF_STREAMER_FAST|CF_NEVER_WAIT);
diff --git a/src/session.c b/src/session.c
index 5f94ad1..ccdd90a 100644
--- a/src/session.c
+++ b/src/session.c
@@ -442,7 +442,6 @@ int session_complete(struct session *s)
 	s->si[0].owner     = t;
 	s->si[0].state     = s->si[0].prev_state = SI_ST_EST;
 	s->si[0].err_type  = SI_ET_NONE;
-	s->si[0].err_loc   = NULL;
 	s->si[0].release   = NULL;
 	s->si[0].send_proxy_ofs = 0;
 	s->si[0].exp       = TICK_ETERNITY;
@@ -461,7 +460,6 @@ int session_complete(struct session *s)
 	s->si[1].state     = s->si[1].prev_state = SI_ST_INI;
 	s->si[1].err_type  = SI_ET_NONE;
 	s->si[1].conn_retries = 0;  /* used for logging too */
-	s->si[1].err_loc   = NULL;
 	s->si[1].release   = NULL;
 	s->si[1].send_proxy_ofs = 0;
 	s->si[1].conn->target = NULL;
@@ -791,7 +789,6 @@ static int sess_update_st_con_tcp(struct session *s, struct stream_interface *si
 			si->state    = SI_ST_EST;
 			si->err_type = SI_ET_DATA_ERR;
 			si->ib->flags |= CF_READ_ERROR | CF_WRITE_ERROR;
-			si->err_loc = objt_server(s->target);
 			return 1;
 		}
 		si->exp   = TICK_ETERNITY;
@@ -806,7 +803,6 @@ static int sess_update_st_con_tcp(struct session *s, struct stream_interface *si
 		if (si->err_type)
 			return 0;
 
-		si->err_loc = objt_server(s->target);
 		if (si->flags & SI_FL_ERR)
 			si->err_type = SI_ET_CONN_ERR;
 		else
@@ -823,7 +819,6 @@ static int sess_update_st_con_tcp(struct session *s, struct stream_interface *si
 		/* give up */
 		si_shutw(si);
 		si->err_type |= SI_ET_CONN_ABRT;
-		si->err_loc  = objt_server(s->target);
 		if (s->srv_error)
 			s->srv_error(s, si);
 		return 1;
@@ -840,7 +835,6 @@ static int sess_update_st_con_tcp(struct session *s, struct stream_interface *si
 	si->exp      = TICK_ETERNITY;
 	si->state    = SI_ST_EST;
 	si->err_type = SI_ET_NONE;
-	si->err_loc  = NULL;
 	return 1;
 }
 
@@ -870,7 +864,6 @@ static int sess_update_st_cer(struct session *s, struct stream_interface *si)
 	if (si->conn_retries < 0) {
 		if (!si->err_type) {
 			si->err_type = SI_ET_CONN_ERR;
-			si->err_loc = objt_server(s->target);
 		}
 
 		if (objt_server(s->target))
@@ -1005,7 +998,6 @@ static void sess_update_stream_int(struct session *s, struct stream_interface *s
 		if (conn_err == SN_ERR_INTERNAL) {
 			if (!si->err_type) {
 				si->err_type = SI_ET_CONN_OTHER;
-				si->err_loc  = srv;
 			}
 
 			if (srv)
-- 
1.8.1.5

