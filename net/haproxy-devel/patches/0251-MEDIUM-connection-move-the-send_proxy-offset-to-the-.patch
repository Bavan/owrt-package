From b8020cefed5d87db7df12c89bb4be6b39d756abd Mon Sep 17 00:00:00 2001
From: Willy Tarreau <w@1wt.eu>
Date: Thu, 24 Oct 2013 21:10:08 +0200
Subject: [PATCH 251/277] MEDIUM: connection: move the send_proxy offset to the
 connection

Till now the send_proxy_ofs field remained in the stream interface,
but since the dynamic allocation of the connection, it makes a lot
of sense to move that into the connection instead of the stream
interface, since it will not be statically allocated for each
session.

Also, it turns out that moving it to the connection fils an alignment
hole on 64 bit architectures so it does not consume more memory, and
removing it from the stream interface was an opportunity to correctly
reorder fields and reduce the stream interface's size from 160 to 144
bytes (-10%). This is 32 bytes saved per session.
---
 include/proto/connection.h       |  1 +
 include/proto/stream_interface.h |  5 ++---
 include/types/connection.h       |  5 +++--
 include/types/stream_interface.h |  5 ++---
 src/backend.c                    |  4 ++--
 src/stream_interface.c           | 12 ++++++------
 6 files changed, 16 insertions(+), 16 deletions(-)

diff --git a/include/proto/connection.h b/include/proto/connection.h
index ce88f6e..576f3fd 100644
--- a/include/proto/connection.h
+++ b/include/proto/connection.h
@@ -490,6 +490,7 @@ static inline void conn_init(struct connection *conn)
 	conn->flags = CO_FL_NONE;
 	conn->data = NULL;
 	conn->owner = NULL;
+	conn->send_proxy_ofs = 0;
 	conn->t.sock.fd = -1; /* just to help with debugging */
 	conn->err_code = CO_ER_NONE;
 	conn->target = NULL;
diff --git a/include/proto/stream_interface.h b/include/proto/stream_interface.h
index 2c69649..46d0c72 100644
--- a/include/proto/stream_interface.h
+++ b/include/proto/stream_interface.h
@@ -54,7 +54,6 @@ static inline void si_reset(struct stream_interface *si, void *owner)
 	si->owner          = owner;
 	si->err_type       = SI_ET_NONE;
 	si->conn_retries   = 0;  /* used for logging too */
-	si->send_proxy_ofs = 0;
 	si->exp            = TICK_ETERNITY;
 	si->flags          = SI_FL_NONE;
 	si->end            = NULL;
@@ -202,7 +201,7 @@ static inline int si_connect(struct stream_interface *si)
 	if (unlikely(!conn || !conn->ctrl || !conn->ctrl->connect))
 		return SN_ERR_INTERNAL;
 
-	ret = conn->ctrl->connect(conn, !channel_is_empty(si->ob), !!si->send_proxy_ofs);
+	ret = conn->ctrl->connect(conn, !channel_is_empty(si->ob), !!conn->send_proxy_ofs);
 	if (ret != SN_ERR_NONE)
 		return ret;
 
@@ -211,7 +210,7 @@ static inline int si_connect(struct stream_interface *si)
 		conn_get_from_addr(conn);
 
 	/* Prepare to send a few handshakes related to the on-wire protocol. */
-	if (si->send_proxy_ofs)
+	if (conn->send_proxy_ofs)
 		conn->flags |= CO_FL_SI_SEND_PROXY;
 
 	/* we need to be notified about connection establishment */
diff --git a/include/types/connection.h b/include/types/connection.h
index 3975743..d600937 100644
--- a/include/types/connection.h
+++ b/include/types/connection.h
@@ -242,13 +242,14 @@ struct conn_src {
  */
 struct connection {
 	enum obj_type obj_type;       /* differentiates connection from applet context */
+	unsigned int flags;           /* CO_FL_* */
 	const struct protocol *ctrl;  /* operations at the socket layer */
 	const struct xprt_ops *xprt;  /* operations at the transport layer */
 	const struct data_cb  *data;  /* data layer callbacks. Must be set before xprt->init() */
-	unsigned int flags;           /* CO_FL_* */
-	int xprt_st;                  /* transport layer state, initialized to zero */
 	void *xprt_ctx;               /* general purpose pointer, initialized to NULL */
 	void *owner;                  /* pointer to upper layer's entity (eg: stream interface) */
+	int xprt_st;                  /* transport layer state, initialized to zero */
+	int send_proxy_ofs;           /* <0 = offset to (re)send from the end, >0 = send all */
 	union {                       /* definitions which depend on connection type */
 		struct {              /*** information used by socket-based connections ***/
 			int fd;       /* file descriptor for a stream driver when known */
diff --git a/include/types/stream_interface.h b/include/types/stream_interface.h
index 47bfc54..d6f8198 100644
--- a/include/types/stream_interface.h
+++ b/include/types/stream_interface.h
@@ -158,17 +158,16 @@ struct stream_interface {
 	unsigned int state;     /* SI_ST* */
 	unsigned int prev_state;/* SI_ST*, copy of previous state */
 	unsigned int flags;     /* SI_FL_* */
-	struct channel *ib, *ob; /* input and output buffers */
 	unsigned int exp;       /* wake up time for connect, queue, turn-around, ... */
+	struct channel *ib, *ob; /* input and output buffers */
 	void *owner;            /* generally a (struct task*) */
-	unsigned int err_type;  /* first error detected, one of SI_ET_* */
 	enum obj_type *end;     /* points to the end point (connection or appctx) */
 
 	struct si_ops *ops;     /* general operations at the stream interface layer */
 
 	/* struct members below are the "remote" part, as seen from the buffer side */
+	unsigned int err_type;  /* first error detected, one of SI_ET_* */
 	int conn_retries;	/* number of connect retries left */
-	int send_proxy_ofs;	/* <0 = offset to (re)send from the end, >0 = send all */
 	struct appctx appctx;   /* context of the running applet if any */
 };
 
diff --git a/src/backend.c b/src/backend.c
index fdfbb9b..55debef 100644
--- a/src/backend.c
+++ b/src/backend.c
@@ -1014,9 +1014,9 @@ int connect_server(struct session *s)
 	si_attach_conn(s->req->cons, srv_conn);
 
 	/* process the case where the server requires the PROXY protocol to be sent */
-	s->req->cons->send_proxy_ofs = 0;
+	srv_conn->send_proxy_ofs = 0;
 	if (objt_server(s->target) && (objt_server(s->target)->state & SRV_SEND_PROXY)) {
-		s->req->cons->send_proxy_ofs = 1; /* must compute size */
+		srv_conn->send_proxy_ofs = 1; /* must compute size */
 		cli_conn = objt_conn(s->req->prod->end);
 		if (cli_conn)
 			conn_get_to_addr(cli_conn);
diff --git a/src/stream_interface.c b/src/stream_interface.c
index 69902d7..c502e7f 100644
--- a/src/stream_interface.c
+++ b/src/stream_interface.c
@@ -389,7 +389,7 @@ int conn_si_send_proxy(struct connection *conn, unsigned int flag)
 	 * connection, in which case the connection is validated only once
 	 * we've sent the whole proxy line. Otherwise we use connect().
 	 */
-	while (si->send_proxy_ofs) {
+	while (conn->send_proxy_ofs) {
 		int ret;
 
 		/* The target server expects a PROXY line to be sent first.
@@ -407,13 +407,13 @@ int conn_si_send_proxy(struct connection *conn, unsigned int flag)
 		if (!ret)
 			goto out_error;
 
-		if (si->send_proxy_ofs > 0)
-			si->send_proxy_ofs = -ret; /* first call */
+		if (conn->send_proxy_ofs > 0)
+			conn->send_proxy_ofs = -ret; /* first call */
 
 		/* we have to send trash from (ret+sp for -sp bytes). If the
 		 * data layer has a pending write, we'll also set MSG_MORE.
 		 */
-		ret = send(conn->t.sock.fd, trash.str + ret + si->send_proxy_ofs, -si->send_proxy_ofs,
+		ret = send(conn->t.sock.fd, trash.str + ret + conn->send_proxy_ofs, -conn->send_proxy_ofs,
 			   (conn->flags & CO_FL_DATA_WR_ENA) ? MSG_MORE : 0);
 
 		if (ret == 0)
@@ -428,8 +428,8 @@ int conn_si_send_proxy(struct connection *conn, unsigned int flag)
 			goto out_error;
 		}
 
-		si->send_proxy_ofs += ret; /* becomes zero once complete */
-		if (si->send_proxy_ofs != 0)
+		conn->send_proxy_ofs += ret; /* becomes zero once complete */
+		if (conn->send_proxy_ofs != 0)
 			goto out_wait;
 
 		/* OK we've sent the whole line, we're connected */
-- 
1.8.1.5

