From cd5d7b678e5e0c92631d90998037ec6bd7b09db5 Mon Sep 17 00:00:00 2001
From: Simon Horman <horms@verge.net.au>
Date: Sun, 24 Feb 2013 17:23:38 +0900
Subject: [PATCH 117/179] MEDIUM: Add state to struct check

Add state to struct check. This is currently used to store one bit,
CHK_RUNNING, which is set if a check is running and clear otherwise.
This bit was previously SRV_CHK_RUNNING of the state element of struct
server.

This is in preparation for associating a agent check
with a server which runs as well as the server's existing check.

Signed-off-by: Simon Horman <horms+renesas@verge.net.au>
---
 include/types/server.h | 5 ++++-
 src/checks.c           | 8 ++++----
 src/dumpstats.c        | 2 +-
 3 files changed, 9 insertions(+), 6 deletions(-)

diff --git a/include/types/server.h b/include/types/server.h
index 0e4c33e..bcde01b 100644
--- a/include/types/server.h
+++ b/include/types/server.h
@@ -55,7 +55,6 @@
 /* unused: 0x0100, 0x0200, 0x0400 */
 #define SRV_SEND_PROXY	0x0800	/* this server talks the PROXY protocol */
 #define SRV_NON_STICK	0x1000	/* never add connections allocated to this server to a stick table */
-#define SRV_CHK_RUNNING 0x2000  /* a check is currently running on this server */
 
 /* function which act on servers need to return various errors */
 #define SRV_STATUS_OK       0   /* everything is OK. */
@@ -70,6 +69,9 @@
 #define SRV_CHK_PASSED  0x0002   /* server check succeeded unless FAILED is also set */
 #define SRV_CHK_DISABLE 0x0004   /* server returned a "disable" code */
 
+/* check flags */
+#define CHK_STATE_RUNNING	0x0001  /* this check is currently running */
+
 /* various constants */
 #define SRV_UWGHT_RANGE 256
 #define SRV_UWGHT_MAX   (SRV_UWGHT_RANGE)
@@ -117,6 +119,7 @@ struct check {
 	int send_proxy;				/* send a PROXY protocol header with checks */
 	int inter, fastinter, downinter;        /* checks: time in milliseconds */
 	int result;				/* health-check result : SRV_CHK_* */
+	int state;				/* health-check result : CHK_* */
 	int type;				/* Check type, one of PR_O2_*_CHK */
 	struct server *server;			/* back-pointer to server */
 };
diff --git a/src/checks.c b/src/checks.c
index a2ff237..c37afbd 100644
--- a/src/checks.c
+++ b/src/checks.c
@@ -1315,7 +1315,7 @@ static struct task *process_chk(struct task *t)
 	int ret;
 	int expired = tick_is_expired(t->expire, now_ms);
 
-	if (!(s->state & SRV_CHK_RUNNING)) {
+	if (!(check->state & CHK_STATE_RUNNING)) {
 		/* no check currently running */
 		if (!expired) /* woke up too early */
 			return t;
@@ -1329,7 +1329,7 @@ static struct task *process_chk(struct task *t)
 		/* we'll initiate a new check */
 		set_server_check_status(check, HCHK_STATUS_START, NULL);
 
-		s->state |= SRV_CHK_RUNNING;
+		check->state |= CHK_STATE_RUNNING;
 		check->bi->p = check->bi->data;
 		check->bi->i = 0;
 		check->bo->p = check->bo->data;
@@ -1420,7 +1420,7 @@ static struct task *process_chk(struct task *t)
 
 		/* here, we have seen a synchronous error, no fd was allocated */
 
-		s->state &= ~SRV_CHK_RUNNING;
+		check->state &= ~CHK_STATE_RUNNING;
 		if (s->health > s->rise) {
 			s->health--; /* still good */
 			s->counters.failed_checks++;
@@ -1516,7 +1516,7 @@ static struct task *process_chk(struct task *t)
 				set_server_up(check);
 			}
 		}
-		s->state &= ~SRV_CHK_RUNNING;
+		check->state &= ~CHK_STATE_RUNNING;
 
 		rv = 0;
 		if (global.spread_checks > 0) {
diff --git a/src/dumpstats.c b/src/dumpstats.c
index 9a422c1..be0aac6 100644
--- a/src/dumpstats.c
+++ b/src/dumpstats.c
@@ -2273,7 +2273,7 @@ static int stats_dump_sv_stats(struct stream_interface *si, struct proxy *px, in
 		if (sv->state & SRV_CHECKED) {
 			chunk_appendf(&trash,
 			              "</td><td class=ac><u> %s%s",
-			              (sv->state & SRV_CHK_RUNNING) ? "* " : "",
+			              (sv->check.state & CHK_STATE_RUNNING) ? "* " : "",
 			              get_check_status_info(sv->check.status));
 
 			if (sv->check.status >= HCHK_STATUS_L57DATA)
-- 
1.8.1.5

